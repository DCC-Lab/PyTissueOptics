{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"PyTissueOptics <p>A hardware-accelerated Python module to simulate light transport in arbitrarily complex 3D media with ease.</p> <p></p> <p> </p> <p>This python package is a fast and flexible implementation of Monte Carlo modeling for light transport in diffuse media.  The package is easy to set up and use, and its mesh-based approach makes it a polyvalent tool to simulate  light transport in arbitrarily complex scenes. The package offers both a native Python implementation  and a hardware-accelerated version using OpenCL which supports most GPUs and CPUs. </p> <p>Designed with research and education in mind, the code aims to be clear, modular, and easy to extend for a wide range of applications.</p>"},{"location":"#notable-features","title":"Notable features","text":"<ul> <li>Supports arbitrarily complex mesh-based 3D environments.</li> <li>Normal smoothing for accurate modeling of curved surfaces like lenses.</li> <li>Per-photon data points of deposited energy, fluence rate and intersection events.</li> <li>Hardware accelerated with <code>OpenCL</code> using PyOpenCL.</li> <li>Photon traces &amp; detectors.</li> <li>Import external 3D models (<code>.OBJ</code>).</li> <li>Many 3D visualization options built with Mayavi.</li> <li>Low memory mode with auto-binning to 2D views.</li> <li>Reusable graphics framework to kickstart other raytracing projects like SensorSim.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pytissueoptics\n</code></pre>"},{"location":"#getting-started","title":"Getting started","text":"<p>A command-line interface is available to quicky run a simulation from our pool of examples:</p> <pre><code>python -m pytissueoptics --help\n</code></pre> <p>You can kick start your first simulation using one of our pre-defined scene under the <code>samples</code> module. </p> <pre><code>from pytissueoptics import *\n\n# Define (scene, source, logger)\nN = 500_000\nscene = samples.PhantomTissue()\nsource = DivergentSource(\n   position=Vector(0, 0, -0.1), direction=Vector(0, 0, 1), N=N, diameter=0.2, divergence=0.78\n)\nlogger = EnergyLogger(scene)\n\n# Run\nsource.propagate(scene, logger=logger)\n\n# Stats &amp; Visualizations\nviewer = Viewer(scene, source, logger)\nviewer.reportStats()\n\nviewer.show2D(View2DProjectionX())\nviewer.show2D(View2DProjectionX(solidLabel=\"middleLayer\"))\nviewer.show2D(View2DSurfaceZ(solidLabel=\"middleLayer\", surfaceLabel=\"interface0\"))\nviewer.show1D(Direction.Z_POS)\nviewer.show3D()\n</code></pre>"},{"location":"#expected-output","title":"Expected output","text":"<pre><code>Report of solid 'backLayer'\n  Absorbance: 67.78% (10.53% of total power)\n    Transmittance at 'backLayer_back': 22.4%\n    Transmittance at 'interface0': 4.9%\n    ...\n</code></pre>"},{"location":"#scene-definition","title":"Scene definition","text":"<p>Here is the explicit definition of the above scene sample. We recommend you look at other examples to get familiar with the API. <pre><code>materials = [\n   ScatteringMaterial(mu_s=2, mu_a=1, g=0.8, n=1.4),\n   ScatteringMaterial(mu_s=3, mu_a=1, g=0.8, n=1.7),\n   ScatteringMaterial(mu_s=2, mu_a=1, g=0.8, n=1.4),\n]\nw = 3\nfrontLayer = Cuboid(a=w, b=w, c=0.75, material=materials[0], label=\"frontLayer\")\nmiddleLayer = Cuboid(a=w, b=w, c=0.5, material=materials[1], label=\"middleLayer\")\nbackLayer = Cuboid(a=w, b=w, c=0.75, material=materials[2], label=\"backLayer\")\nlayerStack = backLayer.stack(middleLayer, \"front\").stack(frontLayer, \"front\")\nscene = ScatteringScene([layerStack])\n</code></pre></p>"},{"location":"#hardware-acceleration","title":"Hardware acceleration","text":"<p>Depending on your platform and GPU, you might already have OpenCL drivers installed, which should work out of the box. Run a PyTissueOptics simulation first to see your current status.</p> <p>Follow the instructions on screen to get setup properly. It will offer to run a benchmark test to determine the ideal number of work units for your hardware.  For more help getting OpenCL to work, refer to PyOpenCL's documentation on the matter. Note that you can disable hardware acceleration at any time with <code>disableOpenCL()</code> or by setting the environment variable <code>PTO_DISABLE_OPENCL=1</code>.</p>"},{"location":"#examples","title":"Examples","text":"<p>All examples can be run using the CLI tool:</p> <pre><code>python -m pytissueoptics --list\npython -m pytissueoptics --examples 1,2,3\n</code></pre> <ol> <li>Scene sample</li> <li>Infinite medium</li> <li>Optical lens &amp; saving progress</li> <li>Custom layer stack</li> <li>Sphere in cube</li> <li>Sampling volume simulation</li> </ol> <p>Other scene and benchmark examples are available under /examples, including:</p> <ul> <li>External 3D model</li> <li>Solid transforms</li> <li>Lenses</li> <li>Skin vessel benchmark</li> <li>Spherical shells benchmark</li> </ul>"},{"location":"#known-limitations","title":"Known limitations","text":"<ol> <li>It uses Henyey-Greenstein approximation for scattering direction because it is sufficient most of the time.</li> <li>Reflections are specular, which does not account for the roughness of materials. A Bling-Phong reflection model could be added in a future release.</li> </ol>"},{"location":"#acknowledgment","title":"Acknowledgment","text":"<p>This package was first inspired by the standard, tested, and loved MCML from Wang, Jacques and Zheng , itself based on Prahl and completely documented, explained, dissected by Jacques and Prahl. The original idea of using Monte Carlo for tissue optics calculations was first proposed by Wilson and Adam in 1983.  This would not be possible without the work of these pioneers.</p>"},{"location":"api/","title":"PyTissueOptics API Reference","text":"<p>API Under Construction</p> <p>The API reference is currently under construction. Some classes, functions, and modules may be missing or incomplete.</p> <p>This page provides an overview of the main user-facing classes and functions, as well as links to the complete API reference.</p>"},{"location":"api/#main-user-api","title":"Main User API","text":"<p>These are the main classes and objects you will interact with as a user:</p> <ul> <li>Solids \u2014 3D geometric objects for defining scenes.  </li> <li>ScatteringMaterial \u2014 Defines optical properties of solids.</li> <li>Sources \u2014 Light sources for simulations.  </li> <li>ScatteringScene \u2014 Define a group of solids for Monte-Carlo simulations.</li> <li>EnergyLogger \u2014 Records photon interactions during simulations.</li> <li>Viewer \u2014 Visualize simulation results.</li> </ul> <p>These classes cover the core workflow for building, simulating, and visualizing light propagation.</p>"},{"location":"api/#complete-api-reference","title":"Complete API Reference","text":"<p>Note that the code is separated in two main modules: </p>"},{"location":"api/#monte-carlo-light-propagation","title":"Monte-Carlo light propagation","text":"<ul> <li>rayscattering \u2014 Monte-Carlo photon propagation, statistics, and visualization.</li> </ul>"},{"location":"api/#core-graphics-framework","title":"Core Graphics Framework","text":"<ul> <li>scene \u2014 Core 3D graphics framework with raytracing and visualization.</li> </ul>"},{"location":"api/rayscattering/","title":"Scattering Module","text":""},{"location":"api/rayscattering/#pytissueoptics.rayscattering.Direction","title":"<code>Direction</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>pytissueoptics/rayscattering/display/utils/direction.py</code> <pre><code>class Direction(Enum):\n    X_POS = 0\n    Y_POS = 1\n    Z_POS = 2\n    X_NEG = 3\n    Y_NEG = 4\n    Z_NEG = 5\n\n    def isSameAxisAs(self, other) -&gt; bool:\n        return self.value % 3 == other.value % 3\n\n    @property\n    def axis(self) -&gt; int:\n        \"\"\"Returns an integer between 0 and 2 representing the x, y, or z axis, ignoring direction sign.\"\"\"\n        return self.value % 3\n\n    @property\n    def isNegative(self) -&gt; bool:\n        return self.value &gt;= 3\n\n    @property\n    def isPositive(self) -&gt; bool:\n        return not self.isNegative\n\n    @property\n    def sign(self) -&gt; int:\n        return 1 if self.isPositive else -1\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.Direction.axis","title":"<code>axis</code>  <code>property</code>","text":"<p>Returns an integer between 0 and 2 representing the x, y, or z axis, ignoring direction sign.</p>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.EnergyLogger","title":"<code>EnergyLogger</code>","text":"<p>               Bases: <code>Logger</code></p> Source code in <code>pytissueoptics/rayscattering/energyLogging/energyLogger.py</code> <pre><code>class EnergyLogger(Logger):\n    _data: dict[InteractionKey, InteractionData]\n\n    def __init__(\n        self,\n        scene: ScatteringScene,\n        filepath: str = None,\n        keep3D: bool = True,\n        views: Union[ViewGroup, List[View2D]] = ViewGroup.ALL,\n        defaultViewEnergyType: EnergyType = EnergyType.DEPOSITION,\n        defaultBinSize: Union[float, tuple] = 0.01,\n        infiniteLimits=((-5, 5), (-5, 5), (-5, 5)),\n    ):\n        \"\"\"\n        Log the energy deposited by scattering photons as well as the energy that crossed surfaces. Every interaction\n        is linked to a specific solid and surface of the scene when applicable. This `EnergyLogger` has to be given to\n        a `Source` instance when propagating.\n\n        :param scene: The scene is required to auto-initialize the 2D views correctly. Even if `keep3D` is True, the\n                scene may be used later to correctly create and display the 2D views.\n        :param filepath: (Optional) Load the logger from the given file. When saving, the file will be overwritten.\n        :param keep3D: (Default to True) If False, logged datapoints are automatically binned to predefined 2D `views`\n                and the 3D data is discarded. This allows for a lightweight logger alternative. If True, the 3D data is\n                kept and the 2D views are only computed later if displayed.\n        :param views: The 2D views to track, particularly used when `keep3D` is set to False. Can be a ViewGroup flag\n                or a list of View2D. Default to ViewGroup.ALL which includes the 3 default XYZ projections for the\n                whole scene as well as for each solid, and a projection of each surface in the direction of the surface\n                normal for both the energy entering and leaving the surface. When `keep3D` is False, ViewGroup.All is\n                required to allow calculation of the detailed report for absorbance and transmittance. When `keep3D` is\n                True, the 2D views data is only computed when displayed, so it is equivalent to setting `views` to None.\n        :param defaultBinSize: The default bin size to use when binning the 3D data to 2D views. In the same physical\n                units as the scene. Custom bin sizes can be specified in each View2D.\n        :param infiniteLimits: The default limits to use for the 2D views when the scene is infinite (has no solids).\n        \"\"\"\n        self._scene = scene\n        self._keep3D = keep3D\n        self._defaultBinSize = defaultBinSize\n        self._infiniteLimits = infiniteLimits\n        self._viewFactory = ViewFactory(scene, defaultBinSize, infiniteLimits, energyType=defaultViewEnergyType)\n\n        self._sceneHash = hash(scene)\n        self._defaultViews = views\n        self._views = self._viewFactory.build(views)\n        self._outdatedViews = set()\n        self._nDataPointsRemoved = 0\n\n        super().__init__(fromFilepath=filepath)\n\n    def addView(self, view: View2D) -&gt; bool:\n        self._viewFactory.build([view])\n\n        if self._viewExists(view):\n            return True\n\n        if self.isEmpty:\n            self._views.append(view)\n            return True\n\n        if self.has3D:\n            self._compileViews([view], detectedBy=view.detectedBy)\n            self._views.append(view)\n            return True\n\n        for i, existingView in enumerate(self._views):\n            if view.isContainedBy(existingView):\n                view.initDataFrom(existingView)\n                if existingView in self._outdatedViews:\n                    self._outdatedViews.add(view)\n                self._views.append(view)\n                return True\n\n        utils.warn(\n            f\"ERROR: Cannot create view {view.name}. The 3D data was discarded and the required data was not \"\n            f\"found in existing views.\"\n        )\n        return False\n\n    def updateView(self, view: View2D):\n        if view in self._outdatedViews:\n            self._compileViews([view])\n\n    def showView(self, view: View2D = None, viewIndex: int = None, logScale: bool = True, colormap: str = \"viridis\"):\n        assert viewIndex is not None or view is not None, \"Either `viewIndex` or `view` must be specified.\"\n\n        if viewIndex is None:\n            created = self.addView(view)\n            if not created:\n                utils.warn(f\"ERROR: Cannot display view {view.name}. Failed to create the view.\")\n                return\n            viewIndex = self._getViewIndex(view)\n\n        view = self.getView(viewIndex)\n        self.updateView(view)\n\n        view.show(logScale=logScale, colormap=colormap)\n\n    def listViews(self):\n        print(\"Available views:\")\n        for i, view in enumerate(self._views):\n            print(f\"\\t{i}: {view.description}\")\n\n    def save(self, filepath: str = None):\n        if filepath is None and self._filepath is None:\n            filepath = self.DEFAULT_LOGGER_PATH\n            utils.warn(f\"No filepath specified. Saving to {filepath}.\")\n        elif filepath is None:\n            filepath = self._filepath\n\n        with open(filepath, \"wb\") as file:\n            pickle.dump(\n                (\n                    self._data,\n                    self.info,\n                    self._labels,\n                    self._views,\n                    self._defaultViews,\n                    self._outdatedViews,\n                    self._nDataPointsRemoved,\n                    self._sceneHash,\n                    self.has3D,\n                ),\n                file,\n            )\n\n    def load(self, filepath: str):\n        self._filepath = filepath\n\n        if not os.path.exists(filepath):\n            utils.warn(\n                \"No logger file found at '{}'. No data loaded, but it will create a new file \"\n                \"at this location if the logger is saved later on.\".format(filepath)\n            )\n            return\n\n        with open(filepath, \"rb\") as file:\n            (\n                self._data,\n                self.info,\n                self._labels,\n                self._views,\n                oldDefaultViews,\n                self._outdatedViews,\n                self._nDataPointsRemoved,\n                oldSceneHash,\n                oldHas3D,\n            ) = pickle.load(file)\n\n        if oldSceneHash != self._sceneHash:\n            utils.warn(\n                \"WARNING: The scene used to create the logger at '{}' is different from the current \"\n                \"scene. This may corrupt statistics and visualization. Proceed at your own risk.\".format(filepath)\n            )\n        if oldHas3D and not self._keep3D:\n            utils.warn(\n                \"WARNING: The logger at '{}' use to store 3D data, but it was reloaded with keep3D=False. \"\n                \"The 3D data will be compiled to 2D views and discarded.\".format(filepath)\n            )\n        if not oldHas3D and self._keep3D:\n            utils.warn(\n                \"WARNING: The logger at '{}' use to discard 3D data, but it was reloaded with keep3D=True. \"\n                \"This may corrupt the statistics and the 3D visualization. Proceed at your own risk.\".format(filepath)\n            )\n        if self._defaultViews != oldDefaultViews:\n            utils.warn(\n                \"WARNING: Cannot provide new default views to a loaded logger from '{}'.\"\n                \"Using only the views from the file.\".format(filepath)\n            )\n\n    @property\n    def views(self) -&gt; List[View2D]:\n        return self._views\n\n    def getView(self, index: int) -&gt; View2D:\n        if index &lt; 0 or index &gt;= len(self._views):\n            raise IndexError(\n                f\"View index {index} is out of range [0, {len(self._views)}]. Use `.listViews()` to see \"\n                f\"available views.\"\n            )\n        return self._views[index]\n\n    def _getViewIndex(self, view: View2D) -&gt; int:\n        for i, v in enumerate(self._views):\n            if v.isEqualTo(view):\n                return i\n        raise ValueError(f\"View {view.name} not found in the list of views.\")\n\n    def _viewExists(self, view: View2D) -&gt; bool:\n        return any([view.isEqualTo(v) for v in self._views])\n\n    @property\n    def has3D(self) -&gt; bool:\n        return self._keep3D\n\n    @property\n    def defaultBinSize(self) -&gt; float:\n        return self._defaultBinSize\n\n    @property\n    def infiniteLimits(self) -&gt; tuple:\n        return self._infiniteLimits\n\n    def getSolidLimits(self, solidLabel: str) -&gt; List[List[float]]:\n        return self._scene.getSolid(solidLabel).getBoundingBox().xyzLimits\n\n    def logDataPointArray(self, array: np.ndarray, key: InteractionKey):\n        \"\"\"\n        Used internally by `Source` when propagating photons. Overwrites the `Logger` method to automatically bin the\n        data to 2D views if 3D data is being discarded.\n        \"\"\"\n        super().logDataPointArray(array, key)\n        self._outdatedViews = set(self._views)\n\n        if not self._keep3D:\n            self._compileViews(self._views)\n            self._delete3DData()\n\n    def logDataPoint(self, value: float, position: Vector, key: InteractionKey, ID: Optional[int] = None):\n        dataPoint = [value, *position.array]\n        if ID is not None:\n            dataPoint.append(ID)\n        self.logDataPointArray(np.array([dataPoint]), key)\n\n    def _compileViews(self, views: List[View2D], detectedBy: Union[str, List[str]] = None):\n        if detectedBy is None:\n            dataPerInteraction = self._data\n            if any(view.detectedBy for view in views):\n                utils.warn(\n                    \"Ignoring the detectedBy property of a view. Can only use detectedBy when adding a view after the \"\n                    \"simulation with keep3D=True.\"\n                )\n        else:\n            dataPerInteraction = self.getFiltered(detectedBy)._data\n\n        for key, data in dataPerInteraction.items():\n            datapointsContainer: Optional[ListArrayContainer] = data.dataPoints\n            if datapointsContainer is None or len(datapointsContainer) == 0:\n                continue\n            for view in views:\n                if view.solidLabel and not utils.labelsEqual(view.solidLabel, key.solidLabel):\n                    continue\n                if view.surfaceLabel and not utils.labelsEqual(view.surfaceLabel, key.surfaceLabel):\n                    continue\n                if view.surfaceLabel is None and key.surfaceLabel is not None:\n                    continue\n\n                data = datapointsContainer.getData()\n                if view.energyType == EnergyType.FLUENCE_RATE:\n                    data = self._fluenceTransform(key, data)\n\n                view.extractData(data)\n        for view in views:\n            self._outdatedViews.discard(view)\n\n    def _delete3DData(self):\n        self._nDataPointsRemoved += super().nDataPoints\n        self._data.clear()\n\n    @property\n    def nDataPoints(self) -&gt; int:\n        \"\"\"\n        Overwrites the `Logger` method to return the total number of data points logged, including the ones discarded.\n        \"\"\"\n        if self._keep3D:\n            return super().nDataPoints\n        else:\n            return self._nDataPointsRemoved\n\n    @property\n    def isEmpty(self) -&gt; bool:\n        return self.nDataPoints == 0\n\n    def logPoint(self, point: Vector, key: InteractionKey = None):\n        raise NotImplementedError(\"Can only log data points to an EnergyLogger.\")\n\n    def logPointArray(self, array: np.ndarray, key: InteractionKey = None):\n        raise NotImplementedError(\"Can only log data points to an EnergyLogger.\")\n\n    def logSegment(self, start: Vector, end: Vector, key: InteractionKey = None):\n        raise NotImplementedError(\"Can only log data points to an EnergyLogger.\")\n\n    def logSegmentArray(self, array: np.ndarray, key: InteractionKey = None):\n        raise NotImplementedError(\"Can only log data points to an EnergyLogger.\")\n\n    def getDataPoints(self, key: InteractionKey, energyType=EnergyType.DEPOSITION) -&gt; np.ndarray:\n        \"\"\"All 3D data points recorded for this InteractionKey (not binned). Array of shape (n, 4) where\n        the second axis is (value, x, y, z). The value can be the energy deposited, the fluence rate, or the\n        energy that crossed the surface.\n\n        :param key: Filtering the data by solidLabel and surfaceLabel.\n        :param energyType: The type of volumetric energy to return when no surfaceLabel is given.\n\n        :return: The data points (value, x, y, z) for the given solidLabel and surfaceLabel. If a surfaceLabel is given,\n        the value corresponds to the energy that crossed the surface (positive when in the direction of the normal). If\n        only a solidLabel is given, the value corresponds to the volumetric EnergyType at that point.\n        \"\"\"\n        if energyType == EnergyType.FLUENCE_RATE:\n            return self._getData(DataType.DATA_POINT, key, transform=self._fluenceTransform)\n\n        return self._getData(DataType.DATA_POINT, key)\n\n    def filter(self, detectedBy: Union[str, List[str]]) -&gt; None:\n        \"\"\"Keeps only the data points from photons detected by one of the specified detector(s).\"\"\"\n        if not self._keep3D:\n            utils.warn(\"Cannot filter a logger that has discarded the 3D data.\")\n            return\n\n        filteredPhotonIDs = self._getDetectedPhotonIDs(detectedBy)\n        self._data = self._getDataForPhotons(filteredPhotonIDs)\n        self._outdatedViews = set(self._views)\n\n    def getFiltered(self, detectedBy: Union[str, List[str]]) -&gt; \"EnergyLogger\":\n        \"\"\"\n        Returns a new logger with only data from photons detected by one of the specified detector(s).\n        \"\"\"\n        filteredLogger = EnergyLogger(self._scene, views=[])\n        filteredPhotonIDs = self._getDetectedPhotonIDs(detectedBy)\n        filteredLogger._data = self._getDataForPhotons(filteredPhotonIDs)\n        return filteredLogger\n\n    def _getDetectedPhotonIDs(self, detectedBy: Union[str, List[str]]) -&gt; np.ndarray:\n        \"\"\"Helper to get photon IDs detected by one of the specified detector(s).\"\"\"\n        detector_labels = [detectedBy] if isinstance(detectedBy, str) else detectedBy\n        detector_keys = [InteractionKey(label) for label in detector_labels]\n        photonIDs = self._getPhotonIDs(detector_keys)\n        if len(photonIDs) == 0:\n            utils.warn(f\"No photons detected by: {detectedBy}\")\n        return photonIDs\n\n    def _getPhotonIDs(self, key: Union[InteractionKey, List[InteractionKey], None] = None) -&gt; np.ndarray:\n        \"\"\"Get all unique photon IDs that interacted with one of the given interaction key(s).\"\"\"\n        if isinstance(key, list):\n            all_photon_ids = []\n            for k in key:\n                data = self.getRawDataPoints(k)\n                if data is not None and data.shape[1] &gt;= 5:\n                    all_photon_ids.append(data[:, 4].astype(np.uint32))\n\n            if len(all_photon_ids) == 0:\n                return np.array([], dtype=np.uint32)\n            combined = np.concatenate(all_photon_ids)\n            return np.unique(combined)\n\n        data = self.getRawDataPoints(key)\n        if data is None or data.shape[1] &lt; 5:\n            return np.array([], dtype=np.uint32)\n        return np.unique(data[:, 4].astype(np.uint32))\n\n    def _getDataForPhotons(self, photonIDs: np.ndarray) -&gt; Dict[InteractionKey, InteractionData]:\n        keyToData: Dict[InteractionKey, InteractionData] = {}\n        photonIDs = np.asarray(photonIDs, dtype=np.uint32)\n        for key, interactionData in self._data.items():\n            points: Optional[ListArrayContainer] = interactionData.dataPoints\n            if points is None:\n                continue\n            data = points.getData()\n            if data.shape[1] &lt; 5:\n                continue\n            mask = np.isin(data[:, 4].astype(np.uint32), photonIDs)\n            filteredData = data[mask]\n            if filteredData.size &gt; 0:\n                container = ListArrayContainer()\n                container.append(filteredData)\n                keyToData[key] = InteractionData(dataPoints=container)\n        return keyToData\n\n    def _fluenceTransform(self, key: InteractionKey, data: Optional[np.ndarray]) -&gt; Optional[np.ndarray]:\n        # Converts volumetric data to fluence rate when needed.\n        if not key.volumetric or data is None:\n            return data\n\n        data[:, 0] = data[:, 0] / self._scene.getMaterial(key.solidLabel).mu_a\n        return data\n\n    def export(self, exportName: str):\n        \"\"\"\n        Export the raw 3D data points to a CSV file, along with the scene information to a JSON file.\n\n        The data file &lt;exportName&gt;.csv will be comma-delimited and will contain the following columns:\n        - energy, x, y, z, photon_index, solid_index, surface_index\n\n        Two types of interactions are logged: scattering and surface crossings. In the first case, the energy will be\n        the delta energy deposited at the point and the surface index will be -1. In the second case, the energy\n        will be the total photon energy when crossing the surface, either as positive if leaving the surface\n        (along the normal) or as negative if entering the surface.\n\n        The scene information will be saved in a JSON file named &lt;exportName&gt;.json, which includes details for each solid\n        index and surface index, such as their labels, materials, and geometry. The world information is also exported\n        as solid index -1.\n        \"\"\"\n        if not self.has3D:\n            utils.warn(\"Cannot export data when keep3D is False. No 3D data available.\")\n            return\n\n        solidLabels = []\n        for solid in self._scene.solids:\n            if solid.isStack():\n                solidLabels.extend(solid.getLayerLabels())\n            else:\n                solidLabels.append(solid.getLabel())\n        solidLabels.sort()\n\n        print(\"Exporting raw data to file...\")\n        filepath = f\"{exportName}.csv\"\n        with open(filepath, \"w\") as file:\n            file.write(\"energy,x,y,z,photon_index,solid_index,surface_index\\n\")\n            self._writeKeyData(file, InteractionKey(WORLD_SOLID_LABEL), -1, -1)\n            for i, solidLabel in enumerate(solidLabels):\n                self._writeKeyData(file, InteractionKey(solidLabel), i, -1)\n                for j, surfaceLabel in enumerate(self._scene.getSurfaceLabels(solidLabel)):\n                    self._writeKeyData(file, InteractionKey(solidLabel, surfaceLabel), i, j)\n        print(f\"Exported data points to {filepath}\")\n\n        self._exportSceneInfo(f\"{exportName}.json\", solidLabels)\n\n    def _writeKeyData(self, file: TextIO, key: InteractionKey, solidIndex: int, surfaceIndex: int):\n        if key not in self._data or self._data[key].dataPoints is None:\n            return\n\n        dataArray = self._data[key].dataPoints.getData()\n        n_rows = dataArray.shape[0]\n\n        output = np.empty((n_rows, 7), dtype=np.float64)\n        output[:, :4] = dataArray[:, :4]\n        output[:, 4] = dataArray[:, 4].astype(np.uint32)\n        output[:, 5] = solidIndex\n        output[:, 6] = surfaceIndex\n\n        np.savetxt(\n            file,\n            output,\n            delimiter=\",\",\n            fmt=[\"%.8e\", \"%.8e\", \"%.8e\", \"%.8e\", \"%d\", \"%d\", \"%d\"],\n        )\n\n    def _exportSceneInfo(self, filepath: str, solidLabels: List[str]):\n        sceneInfo = {}\n        material = self._scene.getWorldEnvironment().material\n        sceneInfo[\"-1\"] = {\"label\": \"world\", \"material\": material.__dict__ if material else None}\n        for i, solidLabel in enumerate(solidLabels):\n            material = self._scene.getMaterial(solidLabel)\n            solid = self._scene.getSolid(solidLabel)\n            surfaces = {}\n            for j, surfaceLabel in enumerate(solid.surfaceLabels):\n                normals = [s.normal for s in solid.getPolygons(surfaceLabel)[:2]]\n                if len(normals) == 1 or normals[0] == normals[1]:\n                    normal = normals[0].array\n                else:\n                    normal = None\n                surfaces[j] = {\"label\": surfaceLabel, \"normal\": normal}\n\n            sceneInfo[str(i)] = {\n                \"label\": solidLabel,\n                \"type\": solid.__class__.__name__,\n                \"material\": material.__dict__ if material else None,\n                \"geometry\": solid.geometryExport(),\n                \"surfaces\": surfaces,\n            }\n\n        with open(filepath, \"w\") as file:\n            json.dump(sceneInfo, file, indent=4)\n        print(f\"Exported scene information to {filepath}\")\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.EnergyLogger.nDataPoints","title":"<code>nDataPoints</code>  <code>property</code>","text":"<p>Overwrites the <code>Logger</code> method to return the total number of data points logged, including the ones discarded.</p>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.EnergyLogger.__init__","title":"<code>__init__(scene, filepath=None, keep3D=True, views=ViewGroup.ALL, defaultViewEnergyType=EnergyType.DEPOSITION, defaultBinSize=0.01, infiniteLimits=((-5, 5), (-5, 5), (-5, 5)))</code>","text":"<p>Log the energy deposited by scattering photons as well as the energy that crossed surfaces. Every interaction is linked to a specific solid and surface of the scene when applicable. This <code>EnergyLogger</code> has to be given to a <code>Source</code> instance when propagating.</p> <p>:param scene: The scene is required to auto-initialize the 2D views correctly. Even if <code>keep3D</code> is True, the         scene may be used later to correctly create and display the 2D views. :param filepath: (Optional) Load the logger from the given file. When saving, the file will be overwritten. :param keep3D: (Default to True) If False, logged datapoints are automatically binned to predefined 2D <code>views</code>         and the 3D data is discarded. This allows for a lightweight logger alternative. If True, the 3D data is         kept and the 2D views are only computed later if displayed. :param views: The 2D views to track, particularly used when <code>keep3D</code> is set to False. Can be a ViewGroup flag         or a list of View2D. Default to ViewGroup.ALL which includes the 3 default XYZ projections for the         whole scene as well as for each solid, and a projection of each surface in the direction of the surface         normal for both the energy entering and leaving the surface. When <code>keep3D</code> is False, ViewGroup.All is         required to allow calculation of the detailed report for absorbance and transmittance. When <code>keep3D</code> is         True, the 2D views data is only computed when displayed, so it is equivalent to setting <code>views</code> to None. :param defaultBinSize: The default bin size to use when binning the 3D data to 2D views. In the same physical         units as the scene. Custom bin sizes can be specified in each View2D. :param infiniteLimits: The default limits to use for the 2D views when the scene is infinite (has no solids).</p> Source code in <code>pytissueoptics/rayscattering/energyLogging/energyLogger.py</code> <pre><code>def __init__(\n    self,\n    scene: ScatteringScene,\n    filepath: str = None,\n    keep3D: bool = True,\n    views: Union[ViewGroup, List[View2D]] = ViewGroup.ALL,\n    defaultViewEnergyType: EnergyType = EnergyType.DEPOSITION,\n    defaultBinSize: Union[float, tuple] = 0.01,\n    infiniteLimits=((-5, 5), (-5, 5), (-5, 5)),\n):\n    \"\"\"\n    Log the energy deposited by scattering photons as well as the energy that crossed surfaces. Every interaction\n    is linked to a specific solid and surface of the scene when applicable. This `EnergyLogger` has to be given to\n    a `Source` instance when propagating.\n\n    :param scene: The scene is required to auto-initialize the 2D views correctly. Even if `keep3D` is True, the\n            scene may be used later to correctly create and display the 2D views.\n    :param filepath: (Optional) Load the logger from the given file. When saving, the file will be overwritten.\n    :param keep3D: (Default to True) If False, logged datapoints are automatically binned to predefined 2D `views`\n            and the 3D data is discarded. This allows for a lightweight logger alternative. If True, the 3D data is\n            kept and the 2D views are only computed later if displayed.\n    :param views: The 2D views to track, particularly used when `keep3D` is set to False. Can be a ViewGroup flag\n            or a list of View2D. Default to ViewGroup.ALL which includes the 3 default XYZ projections for the\n            whole scene as well as for each solid, and a projection of each surface in the direction of the surface\n            normal for both the energy entering and leaving the surface. When `keep3D` is False, ViewGroup.All is\n            required to allow calculation of the detailed report for absorbance and transmittance. When `keep3D` is\n            True, the 2D views data is only computed when displayed, so it is equivalent to setting `views` to None.\n    :param defaultBinSize: The default bin size to use when binning the 3D data to 2D views. In the same physical\n            units as the scene. Custom bin sizes can be specified in each View2D.\n    :param infiniteLimits: The default limits to use for the 2D views when the scene is infinite (has no solids).\n    \"\"\"\n    self._scene = scene\n    self._keep3D = keep3D\n    self._defaultBinSize = defaultBinSize\n    self._infiniteLimits = infiniteLimits\n    self._viewFactory = ViewFactory(scene, defaultBinSize, infiniteLimits, energyType=defaultViewEnergyType)\n\n    self._sceneHash = hash(scene)\n    self._defaultViews = views\n    self._views = self._viewFactory.build(views)\n    self._outdatedViews = set()\n    self._nDataPointsRemoved = 0\n\n    super().__init__(fromFilepath=filepath)\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.EnergyLogger.export","title":"<code>export(exportName)</code>","text":"<p>Export the raw 3D data points to a CSV file, along with the scene information to a JSON file.</p> <p>The data file .csv will be comma-delimited and will contain the following columns: - energy, x, y, z, photon_index, solid_index, surface_index <p>Two types of interactions are logged: scattering and surface crossings. In the first case, the energy will be the delta energy deposited at the point and the surface index will be -1. In the second case, the energy will be the total photon energy when crossing the surface, either as positive if leaving the surface (along the normal) or as negative if entering the surface.</p> <p>The scene information will be saved in a JSON file named .json, which includes details for each solid index and surface index, such as their labels, materials, and geometry. The world information is also exported as solid index -1. Source code in <code>pytissueoptics/rayscattering/energyLogging/energyLogger.py</code> <pre><code>def export(self, exportName: str):\n    \"\"\"\n    Export the raw 3D data points to a CSV file, along with the scene information to a JSON file.\n\n    The data file &lt;exportName&gt;.csv will be comma-delimited and will contain the following columns:\n    - energy, x, y, z, photon_index, solid_index, surface_index\n\n    Two types of interactions are logged: scattering and surface crossings. In the first case, the energy will be\n    the delta energy deposited at the point and the surface index will be -1. In the second case, the energy\n    will be the total photon energy when crossing the surface, either as positive if leaving the surface\n    (along the normal) or as negative if entering the surface.\n\n    The scene information will be saved in a JSON file named &lt;exportName&gt;.json, which includes details for each solid\n    index and surface index, such as their labels, materials, and geometry. The world information is also exported\n    as solid index -1.\n    \"\"\"\n    if not self.has3D:\n        utils.warn(\"Cannot export data when keep3D is False. No 3D data available.\")\n        return\n\n    solidLabels = []\n    for solid in self._scene.solids:\n        if solid.isStack():\n            solidLabels.extend(solid.getLayerLabels())\n        else:\n            solidLabels.append(solid.getLabel())\n    solidLabels.sort()\n\n    print(\"Exporting raw data to file...\")\n    filepath = f\"{exportName}.csv\"\n    with open(filepath, \"w\") as file:\n        file.write(\"energy,x,y,z,photon_index,solid_index,surface_index\\n\")\n        self._writeKeyData(file, InteractionKey(WORLD_SOLID_LABEL), -1, -1)\n        for i, solidLabel in enumerate(solidLabels):\n            self._writeKeyData(file, InteractionKey(solidLabel), i, -1)\n            for j, surfaceLabel in enumerate(self._scene.getSurfaceLabels(solidLabel)):\n                self._writeKeyData(file, InteractionKey(solidLabel, surfaceLabel), i, j)\n    print(f\"Exported data points to {filepath}\")\n\n    self._exportSceneInfo(f\"{exportName}.json\", solidLabels)\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.EnergyLogger.filter","title":"<code>filter(detectedBy)</code>","text":"<p>Keeps only the data points from photons detected by one of the specified detector(s).</p> Source code in <code>pytissueoptics/rayscattering/energyLogging/energyLogger.py</code> <pre><code>def filter(self, detectedBy: Union[str, List[str]]) -&gt; None:\n    \"\"\"Keeps only the data points from photons detected by one of the specified detector(s).\"\"\"\n    if not self._keep3D:\n        utils.warn(\"Cannot filter a logger that has discarded the 3D data.\")\n        return\n\n    filteredPhotonIDs = self._getDetectedPhotonIDs(detectedBy)\n    self._data = self._getDataForPhotons(filteredPhotonIDs)\n    self._outdatedViews = set(self._views)\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.EnergyLogger.getDataPoints","title":"<code>getDataPoints(key, energyType=EnergyType.DEPOSITION)</code>","text":"<p>All 3D data points recorded for this InteractionKey (not binned). Array of shape (n, 4) where the second axis is (value, x, y, z). The value can be the energy deposited, the fluence rate, or the energy that crossed the surface.</p> <p>:param key: Filtering the data by solidLabel and surfaceLabel. :param energyType: The type of volumetric energy to return when no surfaceLabel is given.</p> <p>:return: The data points (value, x, y, z) for the given solidLabel and surfaceLabel. If a surfaceLabel is given, the value corresponds to the energy that crossed the surface (positive when in the direction of the normal). If only a solidLabel is given, the value corresponds to the volumetric EnergyType at that point.</p> Source code in <code>pytissueoptics/rayscattering/energyLogging/energyLogger.py</code> <pre><code>def getDataPoints(self, key: InteractionKey, energyType=EnergyType.DEPOSITION) -&gt; np.ndarray:\n    \"\"\"All 3D data points recorded for this InteractionKey (not binned). Array of shape (n, 4) where\n    the second axis is (value, x, y, z). The value can be the energy deposited, the fluence rate, or the\n    energy that crossed the surface.\n\n    :param key: Filtering the data by solidLabel and surfaceLabel.\n    :param energyType: The type of volumetric energy to return when no surfaceLabel is given.\n\n    :return: The data points (value, x, y, z) for the given solidLabel and surfaceLabel. If a surfaceLabel is given,\n    the value corresponds to the energy that crossed the surface (positive when in the direction of the normal). If\n    only a solidLabel is given, the value corresponds to the volumetric EnergyType at that point.\n    \"\"\"\n    if energyType == EnergyType.FLUENCE_RATE:\n        return self._getData(DataType.DATA_POINT, key, transform=self._fluenceTransform)\n\n    return self._getData(DataType.DATA_POINT, key)\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.EnergyLogger.getFiltered","title":"<code>getFiltered(detectedBy)</code>","text":"<p>Returns a new logger with only data from photons detected by one of the specified detector(s).</p> Source code in <code>pytissueoptics/rayscattering/energyLogging/energyLogger.py</code> <pre><code>def getFiltered(self, detectedBy: Union[str, List[str]]) -&gt; \"EnergyLogger\":\n    \"\"\"\n    Returns a new logger with only data from photons detected by one of the specified detector(s).\n    \"\"\"\n    filteredLogger = EnergyLogger(self._scene, views=[])\n    filteredPhotonIDs = self._getDetectedPhotonIDs(detectedBy)\n    filteredLogger._data = self._getDataForPhotons(filteredPhotonIDs)\n    return filteredLogger\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.EnergyLogger.logDataPointArray","title":"<code>logDataPointArray(array, key)</code>","text":"<p>Used internally by <code>Source</code> when propagating photons. Overwrites the <code>Logger</code> method to automatically bin the data to 2D views if 3D data is being discarded.</p> Source code in <code>pytissueoptics/rayscattering/energyLogging/energyLogger.py</code> <pre><code>def logDataPointArray(self, array: np.ndarray, key: InteractionKey):\n    \"\"\"\n    Used internally by `Source` when propagating photons. Overwrites the `Logger` method to automatically bin the\n    data to 2D views if 3D data is being discarded.\n    \"\"\"\n    super().logDataPointArray(array, key)\n    self._outdatedViews = set(self._views)\n\n    if not self._keep3D:\n        self._compileViews(self._views)\n        self._delete3DData()\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.EnergyType","title":"<code>EnergyType</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Type of volumetric energy: either as the deposited energy in the solid (absorption) or as the fluence rate.</p> Source code in <code>pytissueoptics/rayscattering/energyLogging/energyType.py</code> <pre><code>class EnergyType(Enum):\n    \"\"\"\n    Type of volumetric energy: either as the deposited energy in the solid (absorption) or as the fluence rate.\n    \"\"\"\n\n    DEPOSITION = auto()\n    FLUENCE_RATE = auto()\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.PointCloudStyle","title":"<code>PointCloudStyle</code>","text":"<p>3D display configuration for solid and surface point clouds.</p> Visibility attributes <p>solidLabel (Optional[str]): Only show the point cloud specific to a single solid. surfaceLabel (Optional[str]): Only show the point cloud specific to a single surface of the solid. showSolidPoints (bool): Show the point clouds of the solids. showSurfacePointsLeaving (bool): Show energy that left the surface (direction with surface normal). showSurfacePointsEntering (bool): Show energy that entered the surface (direction opposite to surface normal). energyType (EnergyType): Type of energy to show for volumetric datapoints (deposition or fluence).</p> Other attributes <p>showPointsAsSpheres (bool): Show the points as spheres or as dots. Dots require less memory. pointSize (float): Reference diameter of the points in the point cloud when drawn as spheres. scaleWithValue (bool): Scale the points with their value. A value of 1 yields the <code>pointSize</code>. colormap (str): The name of the colormap to use for the point cloud. reverseColormap (bool): Reverse the colormap. surfacePointSize (float): Same as <code>pointSize</code>, but for the surface points. surfaceScaleWithValue (bool): Same as <code>scaleWithValue</code> but for the surface points. surfaceColormap (str): Same as <code>colormap</code> but for the surface points. surfaceReverseColormap (bool): Same as <code>reverseColormap</code> but for the surface points.</p> Source code in <code>pytissueoptics/rayscattering/display/viewer.py</code> <pre><code>class PointCloudStyle:\n    \"\"\"\n    3D display configuration for solid and surface point clouds.\n\n    Visibility attributes:\n        solidLabel (Optional[str]): Only show the point cloud specific to a single solid.\n        surfaceLabel (Optional[str]): Only show the point cloud specific to a single surface of the solid.\n        showSolidPoints (bool): Show the point clouds of the solids.\n        showSurfacePointsLeaving (bool): Show energy that left the surface (direction with surface normal).\n        showSurfacePointsEntering (bool): Show energy that entered the surface (direction opposite to surface normal).\n        energyType (EnergyType): Type of energy to show for volumetric datapoints (deposition or fluence).\n\n    Other attributes:\n        showPointsAsSpheres (bool): Show the points as spheres or as dots. Dots require less memory.\n        pointSize (float): Reference diameter of the points in the point cloud when drawn as spheres.\n        scaleWithValue (bool): Scale the points with their value. A value of 1 yields the `pointSize`.\n        colormap (str): The name of the colormap to use for the point cloud.\n        reverseColormap (bool): Reverse the colormap.\n        surfacePointSize (float): Same as `pointSize`, but for the surface points.\n        surfaceScaleWithValue (bool): Same as `scaleWithValue` but for the surface points.\n        surfaceColormap (str): Same as `colormap` but for the surface points.\n        surfaceReverseColormap (bool): Same as `reverseColormap` but for the surface points.\n    \"\"\"\n\n    def __init__(\n        self,\n        solidLabel: str = None,\n        surfaceLabel: str = None,\n        showSolidPoints: bool = True,\n        showSurfacePointsLeaving: bool = True,\n        showSurfacePointsEntering: bool = False,\n        energyType=EnergyType.DEPOSITION,\n        detectedBy: Union[str, List[str]] = None,\n        showPointsAsSpheres: bool = False,\n        pointSize: float = 0.15,\n        scaleWithValue: bool = True,\n        colormap: str = \"rainbow\",\n        reverseColormap: bool = False,\n        surfacePointSize: float = 0.01,\n        surfaceScaleWithValue: bool = False,\n        surfaceColormap: str = None,\n        surfaceReverseColormap: bool = None,\n    ):\n        self.solidLabel = solidLabel\n        self.surfaceLabel = surfaceLabel\n        self.showSolidPoints = showSolidPoints\n        self.showSurfacePointsLeaving = showSurfacePointsLeaving\n        self.showSurfacePointsEntering = showSurfacePointsEntering\n        self.energyType = energyType\n        self.detectedBy = detectedBy\n        self.showPointsAsSpheres = showPointsAsSpheres\n\n        self.pointSize = pointSize\n        self.scaleWithValue = scaleWithValue\n        self.colormap = colormap\n        self.reverseColormap = reverseColormap\n\n        self.surfacePointSize = surfacePointSize\n        self.surfaceScaleWithValue = surfaceScaleWithValue\n        self.surfaceColormap = colormap if surfaceColormap is None else surfaceColormap\n        self.surfaceReverseColormap = reverseColormap if surfaceReverseColormap is None else surfaceReverseColormap\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.ScatteringScene","title":"<code>ScatteringScene</code>","text":"<p>               Bases: <code>Scene</code></p> Source code in <code>pytissueoptics/rayscattering/scatteringScene.py</code> <pre><code>class ScatteringScene(Scene):\n    def __init__(self, solids: List[Solid], worldMaterial=ScatteringMaterial(), ignoreIntersections: bool = False):\n        super().__init__(solids, worldMaterial=worldMaterial, ignoreIntersections=ignoreIntersections)\n\n    def add(self, solid: Solid, position: Vector = None):\n        if solid.isFlat and not solid.isDetector:\n            raise Exception(f\"Solid '{solid.getLabel()}' is flat. Flat solids must be used with asDetector().\")\n\n        polygonSample = solid.getPolygons()[0]\n        if not isinstance(polygonSample.insideEnvironment.material, ScatteringMaterial) and not solid.isDetector:\n            raise Exception(\n                f\"Solid '{solid.getLabel()}' has no ScatteringMaterial defined. \"\n                f\"This is required for any RayScatteringScene. \"\n            )\n        super().add(solid, position)\n\n    def show(self, source: Displayable = None, opacity=0.8, colormap=\"cool\", **kwargs):\n        viewer = get3DViewer()\n        self.addToViewer(viewer, opacity=opacity, colormap=colormap, **kwargs)\n        if source:\n            source.addToViewer(viewer)\n        viewer.show()\n\n    def getEstimatedIPP(self, weightThreshold: float) -&gt; float:\n        \"\"\"\n        Get the estimated number of interactions per photon. This gross estimation is done by assuming an infinite\n        medium of mean scene albedo. Used as a starting point for the OpenCL kernel optimization.\n        \"\"\"\n        materials = self.getMaterials()\n        averageAlbedo = sum([mat.getAlbedo() for mat in materials]) / len(materials)\n        estimatedIPP = -np.log(weightThreshold) / averageAlbedo\n        return estimatedIPP\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.ScatteringScene.getEstimatedIPP","title":"<code>getEstimatedIPP(weightThreshold)</code>","text":"<p>Get the estimated number of interactions per photon. This gross estimation is done by assuming an infinite medium of mean scene albedo. Used as a starting point for the OpenCL kernel optimization.</p> Source code in <code>pytissueoptics/rayscattering/scatteringScene.py</code> <pre><code>def getEstimatedIPP(self, weightThreshold: float) -&gt; float:\n    \"\"\"\n    Get the estimated number of interactions per photon. This gross estimation is done by assuming an infinite\n    medium of mean scene albedo. Used as a starting point for the OpenCL kernel optimization.\n    \"\"\"\n    materials = self.getMaterials()\n    averageAlbedo = sum([mat.getAlbedo() for mat in materials]) / len(materials)\n    estimatedIPP = -np.log(weightThreshold) / averageAlbedo\n    return estimatedIPP\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.Stats","title":"<code>Stats</code>","text":"Source code in <code>pytissueoptics/rayscattering/statistics/statistics.py</code> <pre><code>class Stats:\n    def __init__(self, logger: EnergyLogger):\n        self._logger = logger\n        self._pointCloudFactory = PointCloudFactory(logger)\n        self._extractFromViews = not logger.has3D\n\n        self._photonCount = logger.info[\"photonCount\"]\n        self._sourceSolidLabel = logger.info[\"sourceSolidLabel\"]\n\n        self._solidStatsMap = {}\n\n    def report(self, solidLabel: str = None, saveToFile: str = None, verbose=True):\n        if solidLabel and solidLabel not in self._logger.getSeenSolidLabels():\n            utils.warn(f\"WARNING: Cannot compute stats for solid '{solidLabel}' because it was not logged.\")\n            return\n\n        self._computeStats(solidLabel)\n\n        reportString = self._makeReport(solidLabel=solidLabel)\n        if saveToFile:\n            self._saveReport(reportString, saveToFile)\n        if verbose:\n            print(reportString)\n\n    def _computeStats(self, solidLabel: str = None):\n        solidLabels = [solidLabel]\n        if solidLabel is None or utils.labelsEqual(solidLabel, WORLD_SOLID_LABEL):\n            solidLabels = self._logger.getSeenSolidLabels()\n\n        for solidLabel in solidLabels:\n            if solidLabel == WORLD_SOLID_LABEL:\n                continue\n            try:\n                absorbance = self.getAbsorbance(solidLabel)\n            except ZeroDivisionError:\n                utils.warn(\"WARNING: No energy input for solid '{}'\".format(solidLabel))\n                absorbance = None\n            self._solidStatsMap[solidLabel] = SolidStats(\n                absorbance,\n                self.getAbsorbance(solidLabel, useTotalEnergy=True),\n                self.getTransmittance(solidLabel),\n                self._getSurfaceStats(solidLabel),\n            )\n\n    def _makeReport(self, solidLabel: str = None, reportString: str = \"\"):\n        if solidLabel:\n            if solidLabel == WORLD_SOLID_LABEL:\n                reportString += self._reportWorld(solidLabel)\n            else:\n                reportString += self._reportSolid(solidLabel)\n        else:\n            for solidLabel in self._logger.getSeenSolidLabels():\n                reportString = self._makeReport(solidLabel, reportString)\n        return reportString\n\n    def _reportWorld(self, worldLabel: str):\n        totalSolidEnergy = sum([solidStats.totalAbsorbance for solidStats in self._solidStatsMap.values()])\n        reportString = \"Report of '{}'\\n\".format(worldLabel)\n        reportString += \"  Absorbed {:.2f}% of total power\\n\".format(100 - totalSolidEnergy)\n        return reportString\n\n    def _reportSolid(self, solidLabel: str):\n        solidStats = self._solidStatsMap[solidLabel]\n        reportString = \"Report of solid '{}'\\n\".format(solidLabel)\n\n        if solidStats.absorbance == math.inf:\n            # Detectors don't log energy input.\n            reportString += \"  Detected {:.2f}% of total power\\n\".format(solidStats.totalAbsorbance)\n            return reportString\n\n        if solidStats.absorbance is None:\n            reportString += \"  Absorbance: N/A ({:.2f}% of total power)\\n\".format(solidStats.totalAbsorbance)\n            reportString += \"  Absorbance + Transmittance: N/A\\n\"\n            return reportString\n\n        reportString += \"  Absorbance: {:.2f}% ({:.2f}% of total power)\\n\".format(\n            solidStats.absorbance, solidStats.totalAbsorbance\n        )\n        reportString += \"  Absorbance + Transmittance: {:.1f}%\\n\".format(\n            solidStats.absorbance + solidStats.transmittance\n        )\n\n        for surfaceLabel, surfaceStats in solidStats.surfaces.items():\n            reportString += \"    Transmittance at '{}': {:.1f}%\\n\".format(surfaceLabel, surfaceStats.transmittance)\n\n        return reportString\n\n    def getAbsorbance(self, solidLabel: str, useTotalEnergy=False) -&gt; float:\n        if self._extractFromViews:\n            return self._getAbsorbanceFromViews(solidLabel, useTotalEnergy)\n        points = self._getPointCloud(solidLabel).solidPoints\n        energyInput = self.getEnergyInput(solidLabel) if not useTotalEnergy else self.getPhotonCount()\n        return 100 * self._sumEnergy(points) / energyInput if energyInput else math.inf\n\n    def _getAbsorbanceFromViews(self, solidLabel: str, useTotalEnergy=False) -&gt; float:\n        energyInput = self.getEnergyInput(solidLabel) if not useTotalEnergy else self.getPhotonCount()\n        absorbedEnergy = self._getAbsorbedEnergyFromViews(solidLabel)\n        return 100 * absorbedEnergy / energyInput if energyInput else math.inf\n\n    def _getAbsorbedEnergyFromViews(self, solidLabel: str) -&gt; float:\n        for view in self._logger.views:\n            if not isinstance(view, View2DProjection):\n                continue\n            if not utils.labelsEqual(solidLabel, view.solidLabel):\n                continue\n            if not self._viewContainsSolid(view, solidLabel):\n                continue\n            return view.getSum()\n\n        raise Exception(\n            f\"Could not extract absorbance for solid '{solidLabel}'. The 3D data was discarded and \"\n            f\"no stored 2D view corresponds to this solid.\"\n        )\n\n    def _viewContainsSolid(self, view, solidLabel: str) -&gt; bool:\n        solidLimits = self._logger.getSolidLimits(solidLabel)\n        requiredLimitsU = solidLimits[view.axisU]\n        requiredLimitsV = solidLimits[view.axisV]\n        if min(view.limitsU) &gt; min(requiredLimitsU) or max(view.limitsU) &lt; max(requiredLimitsU):\n            return False\n        if min(view.limitsV) &gt; min(requiredLimitsV) or max(view.limitsV) &lt; max(requiredLimitsV):\n            return False\n        return True\n\n    def getPhotonCount(self) -&gt; int:\n        return self._photonCount\n\n    def getEnergyInput(self, solidLabel: str = None) -&gt; float:\n        if solidLabel is None:\n            return self.getPhotonCount()\n        if self._extractFromViews:\n            return self._getEnergyInputFromViews(solidLabel)\n        points = self._getPointCloudOfSurfaces(solidLabel).enteringSurfacePoints\n        energy = self._sumEnergy(points)\n\n        if utils.labelsEqual(self._sourceSolidLabel, solidLabel):\n            energy += self.getPhotonCount()\n        return energy\n\n    def _getEnergyInputFromViews(self, solidLabel: str) -&gt; float:\n        return self._getEnergyCrossingSolidFromViews(solidLabel, leaving=False)\n\n    def _getEnergyLeavingFromViews(self, solidLabel: str):\n        return self._getEnergyCrossingSolidFromViews(solidLabel, leaving=True)\n\n    def _getEnergyCrossingSolidFromViews(self, solidLabel: str, leaving: bool) -&gt; float:\n        energy = 0\n        for surfaceLabel in self._logger.getSeenSurfaceLabels(solidLabel):\n            energy += self._getSurfaceEnergyFromViews(solidLabel, surfaceLabel, leaving=leaving)\n\n        if utils.labelsEqual(self._sourceSolidLabel, solidLabel) and not leaving:\n            energy += self.getPhotonCount()\n        return energy\n\n    def _getSurfaceEnergyFromViews(self, solidLabel: str, surfaceLabel: str, leaving: bool) -&gt; float:\n        for view in self._logger.views:\n            if not utils.labelsEqual(solidLabel, view.solidLabel):\n                continue\n            if not utils.labelsEqual(surfaceLabel, view.surfaceLabel):\n                continue\n            if view.surfaceEnergyLeaving != leaving:\n                continue\n            if not self._viewContainsSolid(view, solidLabel):\n                continue\n            return view.getSum()\n        raise Exception(\n            f\"Could not extract energy {['entering', 'leaving'][leaving]} surface '{surfaceLabel}' \"\n            f\"of solid '{solidLabel}'. The 3D data was discarded and no stored 2D view corresponds \"\n            f\"to this surface.\"\n        )\n\n    def _getSurfaceStats(self, solidLabel: str) -&gt; Dict[str, SurfaceStats]:\n        stats = {}\n        for surfaceLabel in self._logger.getSeenSurfaceLabels(solidLabel):\n            stats[surfaceLabel] = SurfaceStats(self.getTransmittance(solidLabel, surfaceLabel))\n        return stats\n\n    def getTransmittance(self, solidLabel: str, surfaceLabel: str = None, useTotalEnergy=False):\n        \"\"\"Uses local energy input for the desired solid by default. Specify 'useTotalEnergy' = True\n        to compare instead with total input energy of the scene.\"\"\"\n        if self._extractFromViews:\n            return self._getTransmittanceFromViews(solidLabel, surfaceLabel, useTotalEnergy)\n\n        if surfaceLabel is None:\n            points = self._getPointCloudOfSurfaces(solidLabel).leavingSurfacePoints\n        else:\n            points = self._getPointCloud(solidLabel, surfaceLabel).leavingSurfacePoints\n\n        energyInput = self.getEnergyInput(solidLabel) if not useTotalEnergy else self.getPhotonCount()\n        return 100 * self._sumEnergy(points) / energyInput if energyInput else math.inf\n\n    def _getTransmittanceFromViews(self, solidLabel: str, surfaceLabel: str = None, useTotalEnergy=False):\n        if surfaceLabel is None:\n            energyLeaving = self._getEnergyLeavingFromViews(solidLabel)\n        else:\n            energyLeaving = self._getSurfaceEnergyFromViews(solidLabel, surfaceLabel, leaving=True)\n\n        energyInput = self.getEnergyInput(solidLabel) if not useTotalEnergy else self.getPhotonCount()\n        return 100 * energyLeaving / energyInput if energyInput else math.inf\n\n    @staticmethod\n    def _sumEnergy(points: np.ndarray):\n        return np.abs(np.sum(points[:, 0])) if points is not None else 0\n\n    def _getPointCloud(self, solidLabel: str = None, surfaceLabel: str = None) -&gt; PointCloud:\n        return self._pointCloudFactory.getPointCloud(solidLabel, surfaceLabel)\n\n    def _getPointCloudOfSurfaces(self, solidLabel: str = None) -&gt; PointCloud:\n        return self._pointCloudFactory.getPointCloudOfSurfaces(solidLabel)\n\n    @staticmethod\n    def _saveReport(report: str, filepath: str = None):\n        if filepath is None:\n            filepath = \"simulation_report\"\n            utils.warn(f\"WARNING: No filepath specified. Saving to {filepath}.\")\n        i = 0\n        filename, extension = filepath.split(\".\")\n        if extension == \"\":\n            extension = \"txt\"\n        if os.path.exists(filepath):\n            while os.path.exists(\"{}_{}.{}\".format(filepath, i, extension)):\n                i += 1\n            filename = \"{}_{}\".format(filepath, i)\n        filepath = \"{}.{}\".format(filename, extension)\n        with open(filepath, \"wb\") as file:\n            file.write(report.encode(\"utf-8\"))\n            file.close()\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.Stats.getTransmittance","title":"<code>getTransmittance(solidLabel, surfaceLabel=None, useTotalEnergy=False)</code>","text":"<p>Uses local energy input for the desired solid by default. Specify 'useTotalEnergy' = True to compare instead with total input energy of the scene.</p> Source code in <code>pytissueoptics/rayscattering/statistics/statistics.py</code> <pre><code>def getTransmittance(self, solidLabel: str, surfaceLabel: str = None, useTotalEnergy=False):\n    \"\"\"Uses local energy input for the desired solid by default. Specify 'useTotalEnergy' = True\n    to compare instead with total input energy of the scene.\"\"\"\n    if self._extractFromViews:\n        return self._getTransmittanceFromViews(solidLabel, surfaceLabel, useTotalEnergy)\n\n    if surfaceLabel is None:\n        points = self._getPointCloudOfSurfaces(solidLabel).leavingSurfacePoints\n    else:\n        points = self._getPointCloud(solidLabel, surfaceLabel).leavingSurfacePoints\n\n    energyInput = self.getEnergyInput(solidLabel) if not useTotalEnergy else self.getPhotonCount()\n    return 100 * self._sumEnergy(points) / energyInput if energyInput else math.inf\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.ViewGroup","title":"<code>ViewGroup</code>","text":"<p>               Bases: <code>Flag</code></p> <p>A ViewGroup is a bit Flag representing a group of 2D views. They can be combined with the <code>|</code> operator (bitwise OR).</p> It has two different usages <ol> <li>Specify which default views to create when initializing an EnergyLogger, particularly when <code>keep3D</code> is False.</li> <li>Specify which views to show during visualization.</li> </ol> <p>In the first use case, the default views created are three 2D projections of the whole scene (<code>SCENE</code>) or of each solid (<code>SOLIDS</code>) in every XYZ direction.  Except for surface groups, where the default views created include a single 2D projection in the direction of the surface normal.  <code>SURFACES_ENTERING</code> specifies the energy that entered the surface (energy direction opposite to the surface normal).</p> Source code in <code>pytissueoptics/rayscattering/display/views/view2D.py</code> <pre><code>class ViewGroup(Flag):\n    \"\"\"\n    A ViewGroup is a bit Flag representing a group of 2D views. They can be combined with the `|` operator (bitwise OR).\n\n    It has two different usages:\n        1. Specify which default views to create when initializing an EnergyLogger, particularly when `keep3D` is False.\n        2. Specify which views to show during visualization.\n\n    In the first use case, the default views created are three 2D projections of the whole scene (`SCENE`) or of each solid (`SOLIDS`) in every XYZ direction.\n     Except for surface groups, where the default views created include a single 2D projection in the direction of the surface normal.\n     `SURFACES_ENTERING` specifies the energy that entered the surface (energy direction opposite to the surface normal).\n    \"\"\"\n\n    SCENE = 1\n    SOLIDS = 2\n    SURFACES_ENTERING = 4\n    SURFACES_LEAVING = 8\n    SURFACES = SURFACES_ENTERING | SURFACES_LEAVING\n    ALL = SCENE | SOLIDS | SURFACES\n</code></pre>"},{"location":"api/rayscattering/#pytissueoptics.rayscattering.Visibility","title":"<code>Visibility</code>","text":"<p>               Bases: <code>Flag</code></p> <p>A Visibility is a bit Flag representing what to show inside a 3D visualization. They can be combined with the <code>|</code> operator (bitwise OR). <code>AUTO</code> will automatically switch to DEFAULT_3D if 3D data is present, else DEFAULT_2D.</p> Source code in <code>pytissueoptics/rayscattering/display/viewer.py</code> <pre><code>class Visibility(Flag):\n    \"\"\"\n    A Visibility is a bit Flag representing what to show inside a 3D visualization. They can be combined with the `|`\n    operator (bitwise OR). `AUTO` will automatically switch to DEFAULT_3D if 3D data is present, else DEFAULT_2D.\n    \"\"\"\n\n    SCENE = 1\n    SOURCE = 2\n    POINT_CLOUD = 4\n    VIEWS = 8\n    DEFAULT_3D = SCENE | SOURCE | POINT_CLOUD\n    DEFAULT_2D = SCENE | SOURCE | VIEWS\n    AUTO = 0\n</code></pre>"},{"location":"api/scene/","title":"Scene Module","text":""},{"location":"api/scene/#pytissueoptics.scene.Cuboid","title":"<code>Cuboid</code>","text":"<p>               Bases: <code>Solid</code></p> <p>Also known as the Right Rectangular Prism, the Cuboid is defined by its width (a, b, c) in each axis (x, y, z) respectively.</p> <p>The position refers to the vector from global origin to its centroid. The generated mesh will be divided into the following subgroups: Left (-x), Right (+x), Bottom (-y), Top (+y), Front (-z), Back (+z).</p> Source code in <code>pytissueoptics/scene/solids/cuboid.py</code> <pre><code>class Cuboid(Solid):\n    \"\"\"\n    Also known as the Right Rectangular Prism, the Cuboid is defined by its\n    width (a, b, c) in each axis (x, y, z) respectively.\n\n    The position refers to the vector from global origin to its centroid.\n    The generated mesh will be divided into the following subgroups:\n    Left (-x), Right (+x), Bottom (-y), Top (+y), Front (-z), Back (+z).\n    \"\"\"\n\n    def __init__(\n        self,\n        a: float,\n        b: float,\n        c: float,\n        vertices: List[Vertex] = None,\n        position: Vector = Vector(0, 0, 0),\n        surfaces: SurfaceCollection = None,\n        material=None,\n        label: str = \"cuboid\",\n        primitive: str = primitives.DEFAULT,\n        labelOverride=True,\n    ):\n        self.shape = [a, b, c]\n\n        if not vertices:\n            vertices = [\n                Vertex(-a / 2, -b / 2, c / 2),\n                Vertex(a / 2, -b / 2, c / 2),\n                Vertex(a / 2, b / 2, c / 2),\n                Vertex(-a / 2, b / 2, c / 2),\n                Vertex(-a / 2, -b / 2, -c / 2),\n                Vertex(a / 2, -b / 2, -c / 2),\n                Vertex(a / 2, b / 2, -c / 2),\n                Vertex(-a / 2, b / 2, -c / 2),\n            ]\n\n        super().__init__(vertices, position, surfaces, material, label, primitive, labelOverride=labelOverride)\n\n    def _computeTriangleMesh(self):\n        V = self._vertices\n        self._surfaces.add(\"left\", [Triangle(V[4], V[0], V[3]), Triangle(V[3], V[7], V[4])])\n        self._surfaces.add(\"right\", [Triangle(V[1], V[5], V[6]), Triangle(V[6], V[2], V[1])])\n        self._surfaces.add(\"bottom\", [Triangle(V[4], V[5], V[1]), Triangle(V[1], V[0], V[4])])\n        self._surfaces.add(\"top\", [Triangle(V[3], V[2], V[6]), Triangle(V[6], V[7], V[3])])\n        self._surfaces.add(\"front\", [Triangle(V[5], V[4], V[7]), Triangle(V[7], V[6], V[5])])\n        self._surfaces.add(\"back\", [Triangle(V[0], V[1], V[2]), Triangle(V[2], V[3], V[0])])\n\n    def _computeQuadMesh(self):\n        V = self._vertices\n        self._surfaces.add(\"left\", [Quad(V[4], V[0], V[3], V[7])])\n        self._surfaces.add(\"right\", [Quad(V[1], V[5], V[6], V[2])])\n        self._surfaces.add(\"bottom\", [Quad(V[4], V[5], V[1], V[0])])\n        self._surfaces.add(\"top\", [Quad(V[3], V[2], V[6], V[7])])\n        self._surfaces.add(\"front\", [Quad(V[5], V[4], V[7], V[6])])\n        self._surfaces.add(\"back\", [Quad(V[0], V[1], V[2], V[3])])\n\n    def stack(self, other: \"Cuboid\", onSurface: str = \"top\", stackLabel=\"CuboidStack\") -&gt; \"Cuboid\":\n        \"\"\"\n        Basic implementation for stacking cuboids along an axis.\n\n        For example, stacking on 'top' will move the other cuboid on top of this cuboid. They will now share\n         the same mesh at the interface and inside/outside materials at the interface will be properly defined.\n         This will return a new cuboid that represents the stack, with a new 'interface&lt;i&gt;' surface group.\n\n        Limitations:\n            - Requires cuboids with the same shape except along the stack axis.\n            - Cannot stack another stack unless it is along its stacked axis (ill-defined interface material).\n            - Expected behavior not guaranteed for pre-rotated cuboids.\n            - Stacked cuboids will lose reference to their initial stack surface (not a closed solid anymore).\n                Use the returned cuboid stack.\n        \"\"\"\n        stacker = CuboidStacker()\n        stackResult = stacker.stack(onCuboid=self, otherCuboid=other, onSurface=onSurface)\n        return Cuboid._fromStackResult(stackResult, label=stackLabel)\n\n    @classmethod\n    def _fromStackResult(cls, stackResult: StackResult, label: str) -&gt; \"Cuboid\":\n        # subtracting stackCentroid from all vertices because solid creation will translate back to position.\n        for vertex in stackResult.vertices:\n            vertex.subtract(stackResult.position)\n\n        cuboid = Cuboid(\n            *stackResult.shape,\n            position=stackResult.position,\n            vertices=stackResult.vertices,\n            surfaces=stackResult.surfaces,\n            label=label,\n            primitive=stackResult.primitive,\n            labelOverride=False,\n        )\n        cuboid._layerLabels = stackResult.layerLabels\n        return cuboid\n\n    def contains(self, *vertices: Vector) -&gt; bool:\n        relativeVertices = [vertex - self.position for vertex in vertices]\n        relativeVertices = self._applyInverseRotation(relativeVertices)\n\n        relativeVertices = np.asarray([vertex.array for vertex in relativeVertices])\n        bounds = [s / 2 for s in self.shape]\n        if np.any(np.abs(relativeVertices) &gt;= bounds):\n            return False\n\n        if len(vertices) == 1:\n            return True\n\n        if self.isStack():\n            # At this point, all vertices are contained in the bounding box of the stack.\n            # We just need to make sure they are contained in a single layer.\n            return self._aSingleLayerContains(relativeVertices)\n        return True\n\n    def _aSingleLayerContains(self, relativeVertices: np.ndarray) -&gt; bool:\n        for layerLabel in self._layerLabels:\n            bbox = self._getLayerBBox(layerLabel)\n            bboxShape = [bbox.xWidth, bbox.yWidth, bbox.zWidth]\n            bounds = [s / 2 for s in bboxShape]\n            layerOffset = bbox.center - self.position\n            layerRelativeVertices = relativeVertices - np.asarray(layerOffset.array)\n            if np.all(np.abs(layerRelativeVertices) &lt; bounds):\n                return True\n        return False\n\n    def _getLayerBBox(self, layerLabel: str) -&gt; BoundingBox:\n        polygons = self._getLayerPolygons(layerLabel)\n        bbox = BoundingBox.fromPolygons(polygons)\n        return bbox\n\n    def _getLayerPolygons(self, layerLabel: str) -&gt; List[Polygon]:\n        layerSurfaceLabels = self._layerLabels[layerLabel]\n        polygons = []\n        for surfaceLabel in layerSurfaceLabels:\n            polygons.extend(self._surfaces.getPolygons(surfaceLabel))\n        return polygons\n\n    def _geometryParams(self) -&gt; dict:\n        return {\"shape\": self.shape}\n\n    def __hash__(self):\n        baseHash = super().__hash__()\n        if not self.isStack():\n            return baseHash\n\n        materials = set()\n        for surfaceLabel in self.surfaceLabels:\n            material = self.getPolygons(surfaceLabel)[0].insideEnvironment.material\n            materials.add(material)\n        materialsHash = hash(tuple(materials))\n        return hash((baseHash, materialsHash))\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Cuboid.stack","title":"<code>stack(other, onSurface='top', stackLabel='CuboidStack')</code>","text":"<p>Basic implementation for stacking cuboids along an axis.</p> <p>For example, stacking on 'top' will move the other cuboid on top of this cuboid. They will now share  the same mesh at the interface and inside/outside materials at the interface will be properly defined.  This will return a new cuboid that represents the stack, with a new 'interface' surface group. Limitations <ul> <li>Requires cuboids with the same shape except along the stack axis.</li> <li>Cannot stack another stack unless it is along its stacked axis (ill-defined interface material).</li> <li>Expected behavior not guaranteed for pre-rotated cuboids.</li> <li>Stacked cuboids will lose reference to their initial stack surface (not a closed solid anymore).     Use the returned cuboid stack.</li> </ul> Source code in <code>pytissueoptics/scene/solids/cuboid.py</code> <pre><code>def stack(self, other: \"Cuboid\", onSurface: str = \"top\", stackLabel=\"CuboidStack\") -&gt; \"Cuboid\":\n    \"\"\"\n    Basic implementation for stacking cuboids along an axis.\n\n    For example, stacking on 'top' will move the other cuboid on top of this cuboid. They will now share\n     the same mesh at the interface and inside/outside materials at the interface will be properly defined.\n     This will return a new cuboid that represents the stack, with a new 'interface&lt;i&gt;' surface group.\n\n    Limitations:\n        - Requires cuboids with the same shape except along the stack axis.\n        - Cannot stack another stack unless it is along its stacked axis (ill-defined interface material).\n        - Expected behavior not guaranteed for pre-rotated cuboids.\n        - Stacked cuboids will lose reference to their initial stack surface (not a closed solid anymore).\n            Use the returned cuboid stack.\n    \"\"\"\n    stacker = CuboidStacker()\n    stackResult = stacker.stack(onCuboid=self, otherCuboid=other, onSurface=onSurface)\n    return Cuboid._fromStackResult(stackResult, label=stackLabel)\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Cylinder","title":"<code>Cylinder</code>","text":"<p>               Bases: <code>Solid</code></p> Source code in <code>pytissueoptics/scene/solids/cylinder.py</code> <pre><code>class Cylinder(Solid):\n    def __init__(\n        self,\n        radius: float = 1,\n        length: float = 1,\n        u: int = 32,\n        v: int = 3,\n        s: int = 2,\n        position: Vector = Vector(0, 0, 0),\n        material=None,\n        primitive: str = primitives.DEFAULT,\n        label: str = \"cylinder\",\n        smooth=True,\n    ):\n        \"\"\"\n        Default cylinder orientation will be along the z axis. The front face towards the negative z axis and the back\n        face towards the positive z axis. Position refers to its centroid. Available surfaces are \"front\", \"lateral\" and\n        \"back\".\n        \"\"\"\n        self._radius = radius\n        self._length = length\n        if u &lt; 3:\n            raise ValueError(\"u must be &gt;= 3\")\n        if length != 0 and v &lt; 1:\n            raise ValueError(\"v must be &gt;= 1 for non-zero length\")\n        assert radius &gt; 0 and length &gt;= 0\n        self._u = u\n        self._v = v\n        self._s = s\n        self._frontCenter = Vertex(0, 0, 0)\n        self._backCenter = Vertex(0, 0, length)\n        self._minRadius = math.cos(math.pi / self._u) * self._radius\n        self._angularStep = 2 * math.pi / self._u\n        self._lateralStep = self._length / self._v\n        self._radialStep = self._radius / self._s\n\n        super().__init__(\n            position=position, material=material, primitive=primitive, vertices=[], smooth=smooth, label=label\n        )\n        self.translateBy(Vector(0, 0, -length / 2))\n        self._position += Vector(0, 0, length / 2)\n\n    @property\n    def direction(self) -&gt; Vector:\n        direction = self._backCenter - self._frontCenter\n        direction.normalize()\n        return direction\n\n    def _computeTriangleMesh(self):\n        frontLayers, lateralLayers, backLayers = self._computeVerticesOfLayers()\n\n        frontLayers.insert(0, [self._frontCenter])\n        frontLayers.append(lateralLayers[0])\n        backLayers.insert(0, lateralLayers[-1])\n        backLayers.append([self._backCenter])\n        self._vertices.extend([self._frontCenter, self._backCenter])\n\n        self._surfaces.add(\"front\", self._getSurfaceTriangles(frontLayers))\n        self._surfaces.add(\"lateral\", self._getSurfaceTriangles(lateralLayers))\n        self._surfaces.add(\"back\", self._getSurfaceTriangles(backLayers))\n\n    def _computeVerticesOfLayers(self) -&gt; tuple:\n        v = self._v if self._length != 0 else 0\n        frontLayers = self._computeSectionVertices(lateralSteps=[0], radialSteps=list(range(1, self._s)))\n        lateralLayers = self._computeSectionVertices(lateralSteps=list(range(v + 1)), radialSteps=[self._s])\n        backLayers = self._computeSectionVertices(lateralSteps=[v], radialSteps=list(range(self._s - 1, 0, -1)))\n        return frontLayers, lateralLayers, backLayers\n\n    def _computeSectionVertices(self, lateralSteps: List[int], radialSteps: List[int]):\n        verticesLayers = []\n        for k in radialSteps:\n            for j in lateralSteps:\n                layer = []\n                for i in range(self._u):\n                    layer.append(self._createVertex(i, j, k))\n                verticesLayers.append(layer)\n                self._vertices.extend(layer)\n        return verticesLayers\n\n    def _createVertex(self, i: int, j: int, k: int) -&gt; Vertex:\n        shrinkFactor = self._getShrinkFactor(self._lateralStep * j)\n        radiusFactor = k * self._radialStep / self._radius\n        if shrinkFactor != 1:\n            pass  # This is for cones only. In this case we want to keep linear sampling of radius values.\n        else:\n            # For lenses, we usually want a uniform mesh after the curve transform, but this transform tends to push\n            # vertices outwards (particularly at low radius). To prevent a low mesh resolution in the center, we need\n            # to increase the sampling around the center beforehand by forcing smaller radiusFactor values.\n            radiusFactor = radiusFactor**2\n        r = self._radius * radiusFactor * shrinkFactor\n        x = r * math.cos(i * self._angularStep)\n        y = r * math.sin(i * self._angularStep)\n        z = j * self._lateralStep\n        return Vertex(x, y, z)\n\n    def _getSurfaceTriangles(self, verticesLayers: List[List[Vertex]]) -&gt; List[Triangle]:\n        triangles = []\n        for i in range(len(verticesLayers) - 1):\n            currentGroup = verticesLayers[i]\n            nextGroup = verticesLayers[i + 1]\n\n            if len(currentGroup) == 1:\n                triangles.extend(self._getPeakTriangles(self._frontCenter, nextGroup[::-1]))\n                continue\n            if len(nextGroup) == 1:\n                triangles.extend(self._getPeakTriangles(self._backCenter, currentGroup))\n                continue\n\n            for j in range(self._u):\n                nextIndex = (j + 1) % self._u\n                triangles.append(Triangle(currentGroup[j], nextGroup[nextIndex], nextGroup[j]))\n                triangles.append(Triangle(currentGroup[j], currentGroup[nextIndex], nextGroup[nextIndex]))\n        return triangles\n\n    def _getPeakTriangles(self, peakVertex: Vertex, ringVertices: List[Vertex]) -&gt; List[Triangle]:\n        triangles = []\n        for j in range(self._u):\n            nextIndex = (j + 1) % self._u\n            triangles.append(Triangle(peakVertex, ringVertices[j], ringVertices[nextIndex]))\n        return triangles\n\n    def _computeQuadMesh(self):\n        raise NotImplementedError(\"Quad mesh not implemented for Cylinder\")\n\n    def contains(self, *vertices: Vector) -&gt; bool:\n        direction = self.direction\n        basePosition = self._position - direction * self._length / 2\n        for vertex in vertices:\n            localPoint = vertex - basePosition\n            alongCylinder = direction.dot(localPoint)\n            if alongCylinder &lt; 0 or alongCylinder &gt; self._length:\n                return False\n            radiusCheck = self._minRadiusAtHeightAlong(alongCylinder)\n            radialComponent = localPoint - direction * alongCylinder\n            radialDistanceFromBase = radialComponent.getNorm()\n            if radialDistanceFromBase &gt; radiusCheck:\n                return False\n        return True\n\n    def _minRadiusAtHeightAlong(self, heightAlong: float) -&gt; float:\n        shrinkFactor = self._getShrinkFactor(heightAlong)\n        return self._minRadius * shrinkFactor\n\n    @staticmethod\n    def _getShrinkFactor(heightAlong: float) -&gt; float:\n        return 1\n\n    def smooth(self, surfaceLabel: str = None, reset: bool = True):\n        if self._u &lt; 16:\n            warnings.warn(\"Smoothing a cylinder with less than 16 sides (u &lt; 16) may result in intersection errors.\")\n        if surfaceLabel:\n            return super(Cylinder, self).smooth(surfaceLabel, reset)\n        self.smooth(\"lateral\", reset=True)\n\n    def __hash__(self):\n        materialHash = hash(self._material) if self._material else 0\n        propertyHash = hash((self._radius, self._length, self._frontCenter, self._backCenter))\n        return hash((materialHash, propertyHash))\n\n    def _geometryParams(self) -&gt; dict:\n        return {\n            \"radius\": self._radius,\n            \"length\": self._length,\n            \"u\": self._u,\n            \"v\": self._v,\n            \"s\": self._s,\n        }\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Cylinder.__init__","title":"<code>__init__(radius=1, length=1, u=32, v=3, s=2, position=Vector(0, 0, 0), material=None, primitive=primitives.DEFAULT, label='cylinder', smooth=True)</code>","text":"<p>Default cylinder orientation will be along the z axis. The front face towards the negative z axis and the back face towards the positive z axis. Position refers to its centroid. Available surfaces are \"front\", \"lateral\" and \"back\".</p> Source code in <code>pytissueoptics/scene/solids/cylinder.py</code> <pre><code>def __init__(\n    self,\n    radius: float = 1,\n    length: float = 1,\n    u: int = 32,\n    v: int = 3,\n    s: int = 2,\n    position: Vector = Vector(0, 0, 0),\n    material=None,\n    primitive: str = primitives.DEFAULT,\n    label: str = \"cylinder\",\n    smooth=True,\n):\n    \"\"\"\n    Default cylinder orientation will be along the z axis. The front face towards the negative z axis and the back\n    face towards the positive z axis. Position refers to its centroid. Available surfaces are \"front\", \"lateral\" and\n    \"back\".\n    \"\"\"\n    self._radius = radius\n    self._length = length\n    if u &lt; 3:\n        raise ValueError(\"u must be &gt;= 3\")\n    if length != 0 and v &lt; 1:\n        raise ValueError(\"v must be &gt;= 1 for non-zero length\")\n    assert radius &gt; 0 and length &gt;= 0\n    self._u = u\n    self._v = v\n    self._s = s\n    self._frontCenter = Vertex(0, 0, 0)\n    self._backCenter = Vertex(0, 0, length)\n    self._minRadius = math.cos(math.pi / self._u) * self._radius\n    self._angularStep = 2 * math.pi / self._u\n    self._lateralStep = self._length / self._v\n    self._radialStep = self._radius / self._s\n\n    super().__init__(\n        position=position, material=material, primitive=primitive, vertices=[], smooth=smooth, label=label\n    )\n    self.translateBy(Vector(0, 0, -length / 2))\n    self._position += Vector(0, 0, length / 2)\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Ellipsoid","title":"<code>Ellipsoid</code>","text":"<p>               Bases: <code>Solid</code></p> <p>We take the unit sphere, then calculate the theta, phi position of each vertex (with ISO mathematical convention). Then we apply the ellipsoid formula in the spherical coordinate to isolate the component R. We then calculate the difference the ellipsoid would with the unit sphere for this theta,phi and then .add() or .subtract() the corresponding vector.</p> Source code in <code>pytissueoptics/scene/solids/ellipsoid.py</code> <pre><code>class Ellipsoid(Solid):\n    \"\"\"\n    We take the unit sphere, then calculate the theta, phi position of each vertex (with ISO mathematical\n    convention). Then we apply the ellipsoid formula in the spherical coordinate to isolate the component R.\n    We then calculate the difference the ellipsoid would with the unit sphere for this theta,phi and\n    then .add() or .subtract() the corresponding vector.\n    \"\"\"\n\n    def __init__(\n        self,\n        a: float = 1,\n        b: float = 1,\n        c: float = 1,\n        order: int = 3,\n        position: Vector = Vector(0, 0, 0),\n        material=None,\n        label: str = \"ellipsoid\",\n        primitive: str = primitives.DEFAULT,\n        smooth: bool = True,\n    ):\n        self._a = a\n        self._b = b\n        self._c = c\n        self._order = order\n\n        super().__init__(\n            position=position, material=material, label=label, primitive=primitive, vertices=[], smooth=smooth\n        )\n\n    def _computeTriangleMesh(self):\n        \"\"\"\n        The most precise sphere approximation is the IcoSphere, which is generated from the platonic solid,\n        the Icosahedron. It is built with 20 equilateral triangles with exactly the same angle between each.\n        From Euler's method to generate the vertex for the icosahedron, we cross 3 perpendicular planes,\n        with length=2 and width=2*phi. Joining adjacent vertices will produce the Icosahedron.\n\n        From the Icosahedron, we can split each face in 4 triangles, in a recursive manner, to obtain an IcoSphere.\n        The method goes as follows:\n        1 - Find each mid-point between two connecting vertices on a triangle\n        2 - Normalize those new points to project them onto the unit sphere.\n        3 - Connect the new vertices in a way to make 4 new triangles.\n        4 - Do these steps for each triangle (This will lead to redundant calculation, I am aware)\n        5 - Replace the old surfaces by the new surfaces\n        \"\"\"\n\n        self._computeFirstOrderTriangleMesh()\n\n        for i in range(0, self._order):\n            self._computeNextOrderTriangleMesh()\n\n        self._setVerticesPositionsFromCenter()\n\n    def _computeFirstOrderTriangleMesh(self):\n        phi = (1.0 + 5.0 ** (1 / 2)) / 2.0\n        xyPlaneVertices = [Vertex(-1, phi, 0), Vertex(1, phi, 0), Vertex(-1, -phi, 0), Vertex(1, -phi, 0)]\n        yzPlaneVertices = [Vertex(0, -1, phi), Vertex(0, 1, phi), Vertex(0, -1, -phi), Vertex(0, 1, -phi)]\n        xzPlaneVertices = [Vertex(phi, 0, -1), Vertex(phi, 0, 1), Vertex(-phi, 0, -1), Vertex(-phi, 0, 1)]\n        self._vertices = [*xyPlaneVertices, *yzPlaneVertices, *xzPlaneVertices]\n        V = self._vertices\n\n        self._surfaces.add(\n            \"ellipsoid\",\n            [\n                Triangle(V[0], V[11], V[5]),\n                Triangle(V[0], V[5], V[1]),\n                Triangle(V[0], V[1], V[7]),\n                Triangle(V[0], V[7], V[10]),\n                Triangle(V[0], V[10], V[11]),\n                Triangle(V[1], V[5], V[9]),\n                Triangle(V[5], V[11], V[4]),\n                Triangle(V[11], V[10], V[2]),\n                Triangle(V[10], V[7], V[6]),\n                Triangle(V[7], V[1], V[8]),\n                Triangle(V[3], V[9], V[4]),\n                Triangle(V[3], V[4], V[2]),\n                Triangle(V[3], V[2], V[6]),\n                Triangle(V[3], V[6], V[8]),\n                Triangle(V[3], V[8], V[9]),\n                Triangle(V[4], V[9], V[5]),\n                Triangle(V[2], V[4], V[11]),\n                Triangle(V[6], V[2], V[10]),\n                Triangle(V[8], V[6], V[7]),\n                Triangle(V[9], V[8], V[1]),\n            ],\n        )\n\n    def _computeNextOrderTriangleMesh(self):\n        newPolygons = []\n        self._verticesCache = {}\n        for j, polygon in enumerate(self.getPolygons()):\n            ai = self._createMidVertex(polygon.vertices[0], polygon.vertices[1])\n            bi = self._createMidVertex(polygon.vertices[1], polygon.vertices[2])\n            ci = self._createMidVertex(polygon.vertices[2], polygon.vertices[0])\n            newVertices = [ai, bi, ci]\n            for i, vertex in enumerate(newVertices):\n                vHash = hash2((vertex.x, vertex.y, vertex.z))\n                if vHash in self._verticesCache:\n                    newVertices[i] = self._verticesCache[vHash]\n                    self._verticesCache.pop(vHash)\n                else:\n                    self._vertices.append(vertex)\n                    self._verticesCache[vHash] = vertex\n\n            newPolygons.append(Triangle(polygon.vertices[0], newVertices[0], newVertices[2]))\n            newPolygons.append(Triangle(polygon.vertices[1], newVertices[1], newVertices[0]))\n            newPolygons.append(Triangle(polygon.vertices[2], newVertices[2], newVertices[1]))\n            newPolygons.append(Triangle(newVertices[0], newVertices[1], newVertices[2]))\n\n        self._surfaces.setPolygons(\"ellipsoid\", newPolygons)\n\n    @staticmethod\n    def _createMidVertex(p1, p2):\n        middle = Vertex((p1.x + p2.x) / 2, (p1.y + p2.y) / 2, (p1.z + p2.z) / 2)\n        return middle\n\n    def _setVerticesPositionsFromCenter(self):\n        \"\"\"\n        The Ellipsoid parametric equation goes as: x^2/a^2 + y^2/b^2 + z^2/c^2 =1\n        A Sphere is just an ellipsoid with a = b = c.\n        Bringing (x, y, z) -&gt; (theta, phi, r) we can simply take the unit sphere and stretch it,\n        since the equation becomes as follow:\n\n        r^2.cos^2(theta).sin^2(phi)/a^2 + r^2.sin^2(theta).sin^2(phi)/b^2  + r^2.cos^2(phi)/c^2 = 1\n        \"\"\"\n        for vertex in self._vertices:\n            vertex.normalize()\n            r = self._radiusTowards(vertex)\n            distanceFromUnitSphere = r - 1.0\n            vertex.add(vertex * distanceFromUnitSphere)\n        self.surfaces.resetNormals()\n\n    @staticmethod\n    def _findThetaPhi(vertex: Vertex):\n        phi = math.acos(vertex.z / (vertex.x**2 + vertex.y**2 + vertex.z**2))\n        theta = 0\n        if vertex.x == 0.0:\n            if vertex.y &gt; 0.0:\n                theta = math.pi / 2\n\n            elif vertex.y &lt; 0.0:\n                theta = -math.pi / 2\n\n        elif vertex.x &gt; 0.0:\n            theta = math.atan(vertex.y / vertex.x)\n\n        elif vertex.x &lt; 0.0:\n            if vertex.y &gt;= 0.0:\n                theta = math.atan(vertex.y / vertex.x) + math.pi\n\n            elif vertex.y &lt; 0.0:\n                theta = math.atan(vertex.y / vertex.x) - math.pi\n\n        return theta, phi\n\n    def _radiusTowards(self, vertex):\n        theta, phi = self._findThetaPhi(vertex)\n        return math.sqrt(\n            1\n            / (\n                (math.cos(theta) ** 2 * math.sin(phi) ** 2) / self._a**2\n                + (math.sin(theta) ** 2 * math.sin(phi) ** 2) / self._b**2\n                + math.cos(phi) ** 2 / self._c**2\n            )\n        )\n\n    def _computeQuadMesh(self):\n        raise NotImplementedError\n\n    def contains(self, *vertices: Vector) -&gt; bool:\n        \"\"\"Only returns true if all vertices are inside the minimum radius of the ellipsoid\n        towards each vertex direction (more restrictive with low order ellipsoids).\"\"\"\n        relativeVertices = [vertex - self.position for vertex in vertices]\n        relativeVertices = self._applyInverseRotation(relativeVertices)\n        relativeVerticesArray = np.asarray([vertex.array for vertex in relativeVertices])\n\n        for relativeVertexArray in relativeVerticesArray:\n            relativeVertex = Vertex(*relativeVertexArray)\n            vertexRadius = relativeVertex.getNorm()\n            relativeVertex.normalize()\n            if vertexRadius == 0:\n                continue\n            minRadius = self._getMinimumRadiusTowards(relativeVertex)\n            if vertexRadius &gt;= minRadius:\n                return False\n        return True\n\n    def _getRadiusError(self) -&gt; float:\n        aPolygon = self.surfaces.getPolygons()[0]\n        centerVertex = Vertex(0, 0, 0)\n        for vertex in aPolygon.vertices:\n            centerVertex.add(vertex)\n        centerVertex.divide(len(aPolygon.vertices))\n        centerVertex.subtract(self.position)\n\n        localMinimumRadius = centerVertex.getNorm()\n        localTrueRadius = self._radiusTowards(centerVertex)\n        return abs(localTrueRadius - localMinimumRadius) / localTrueRadius\n\n    def _getMinimumRadiusTowards(self, vertex) -&gt; float:\n        return (1 - self._getRadiusError()) * self._radiusTowards(vertex)\n\n    def _geometryParams(self) -&gt; dict:\n        return {\n            \"radius_a\": self._a,\n            \"radius_b\": self._b,\n            \"radius_c\": self._c,\n            \"order\": self._order,\n        }\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Ellipsoid.contains","title":"<code>contains(*vertices)</code>","text":"<p>Only returns true if all vertices are inside the minimum radius of the ellipsoid towards each vertex direction (more restrictive with low order ellipsoids).</p> Source code in <code>pytissueoptics/scene/solids/ellipsoid.py</code> <pre><code>def contains(self, *vertices: Vector) -&gt; bool:\n    \"\"\"Only returns true if all vertices are inside the minimum radius of the ellipsoid\n    towards each vertex direction (more restrictive with low order ellipsoids).\"\"\"\n    relativeVertices = [vertex - self.position for vertex in vertices]\n    relativeVertices = self._applyInverseRotation(relativeVertices)\n    relativeVerticesArray = np.asarray([vertex.array for vertex in relativeVertices])\n\n    for relativeVertexArray in relativeVerticesArray:\n        relativeVertex = Vertex(*relativeVertexArray)\n        vertexRadius = relativeVertex.getNorm()\n        relativeVertex.normalize()\n        if vertexRadius == 0:\n            continue\n        minRadius = self._getMinimumRadiusTowards(relativeVertex)\n        if vertexRadius &gt;= minRadius:\n            return False\n    return True\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Loader","title":"<code>Loader</code>","text":"<p>Base class to manage the conversion between files and Scene() or Solid() from various types of files.</p> Source code in <code>pytissueoptics/scene/loader/loader.py</code> <pre><code>class Loader:\n    \"\"\"\n    Base class to manage the conversion between files and Scene() or Solid() from\n    various types of files.\n    \"\"\"\n\n    def __init__(self):\n        self._filepath: str = \"\"\n        self._fileExtension: str = \"\"\n        self._parser = None\n\n    def load(self, filepath: str, showProgress: bool = True) -&gt; List[Solid]:\n        self._filepath = filepath\n        self._fileExtension = self._getFileExtension()\n        self._selectParser(showProgress)\n        return self._convert(showProgress)\n\n    def _getFileExtension(self) -&gt; str:\n        return pathlib.Path(self._filepath).suffix\n\n    def _selectParser(self, showProgress: bool = True):\n        ext = self._fileExtension\n        if ext == \".obj\":\n            self._parser = OBJParser(self._filepath, showProgress)\n        else:\n            raise NotImplementedError(\"This format is not supported.\")\n\n    def _convert(self, showProgress: bool = True) -&gt; List[Solid]:\n        vertices = []\n        for vertex in self._parser.vertices:\n            vertices.append(Vertex(*vertex))\n\n        totalProgressBarLength = 0\n        for objectName, _object in self._parser.objects.items():\n            totalProgressBarLength += len(_object.surfaces.items())\n        pbar = progressBar(\n            total=totalProgressBarLength,\n            desc=\"Converting File '{}'\".format(self._filepath.split(\"/\")[-1]),\n            unit=\"surfaces\",\n            disable=not showProgress,\n        )\n\n        solids = []\n        for objectName, _object in self._parser.objects.items():\n            surfaces = SurfaceCollection()\n            for surfaceLabel, surface in _object.surfaces.items():\n                surfaces.add(surfaceLabel, self._convertSurfaceToTriangles(surface, vertices))\n                pbar.update(1)\n            solids.append(\n                Solid(\n                    position=Vector(0, 0, 0),\n                    vertices=vertices,\n                    surfaces=surfaces,\n                    primitive=primitives.POLYGON,\n                    label=objectName,\n                )\n            )\n\n        pbar.close()\n        return solids\n\n    @staticmethod\n    def _convertSurfaceToTriangles(surface: ParsedSurface, vertices: List[Vertex]) -&gt; List[Triangle]:\n        \"\"\"Converting to triangles only since loaded polygons are often not planar.\"\"\"\n        triangles = []\n        for polygonIndices in surface.polygons:\n            polygonVertices = [vertices[i] for i in polygonIndices]\n            for i in range(len(polygonVertices) - 2):\n                triangles.append(Triangle(polygonVertices[0], polygonVertices[i + 1], polygonVertices[i + 2]))\n        return triangles\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Logger","title":"<code>Logger</code>","text":"Source code in <code>pytissueoptics/scene/logger/logger.py</code> <pre><code>class Logger:\n    DEFAULT_LOGGER_PATH = \"simulation.log\"\n\n    def __init__(self, fromFilepath: str = None):\n        self._data: Dict[InteractionKey, InteractionData] = {}\n        self.info: dict = {}\n        self._filepath = None\n        self._labels = {}\n\n        if fromFilepath:\n            self.load(fromFilepath)\n\n    def getSeenSolidLabels(self) -&gt; List[str]:\n        \"\"\"Returns a list of all solid labels that have been logged in the past\n        even if the data was discarded.\"\"\"\n        return list(self._labels.keys())\n\n    def getSeenSurfaceLabels(self, solidLabel: str) -&gt; List[str]:\n        \"\"\"Returns a list of all surface labels that have been logged in the past\n        for the given solid even if the data was discarded.\"\"\"\n        return self._labels[solidLabel]\n\n    def getStoredSolidLabels(self) -&gt; List[str]:\n        \"\"\"Returns a list of all solid labels that are currently stored in the logger.\"\"\"\n        return list(set(key.solidLabel for key in self._data.keys()))\n\n    def getStoredSurfaceLabels(self, solidLabel: str) -&gt; List[str]:\n        \"\"\"Returns a list of all surface labels that are currently stored in the logger.\"\"\"\n        return [\n            key.surfaceLabel\n            for key in self._data.keys()\n            if key.solidLabel == solidLabel and key.surfaceLabel is not None\n        ]\n\n    def logPoint(self, point: Vector, key: InteractionKey = None):\n        self._appendData([point.x, point.y, point.z], DataType.POINT, key)\n\n    def logDataPoint(self, value: float, position: Vector, key: InteractionKey, ID: Optional[int] = None):\n        dataPoint = [value, *position.array]\n        if ID is not None:\n            dataPoint.append(ID)\n        self._appendData(dataPoint, DataType.DATA_POINT, key)\n\n    def logSegment(self, start: Vector, end: Vector, key: InteractionKey = None):\n        self._appendData([start.x, start.y, start.z, end.x, end.y, end.z], DataType.SEGMENT, key)\n\n    def logPointArray(self, array: np.ndarray, key: InteractionKey = None):\n        \"\"\"'array' must be of shape (n, 3) where the second axis is (x, y, z)\"\"\"\n        assert array.shape[1] == 3 and array.ndim == 2, \"Point array must be of shape (n, 3)\"\n        self._appendData(array, DataType.POINT, key)\n\n    def logDataPointArray(self, array: np.ndarray, key: InteractionKey):\n        \"\"\"'array' must be of shape (n, 4) or (n, 5) where the second axis is (value, x, y, z)\n        or (value, x, y, z, photonID). The photonID column is optional.\"\"\"\n        assert array.shape[1] in [4, 5] and array.ndim == 2, \"Data point array must be of shape (n, 4) or (n, 5)\"\n        self._appendData(array, DataType.DATA_POINT, key)\n\n    def logSegmentArray(self, array: np.ndarray, key: InteractionKey = None):\n        \"\"\"'array' must be of shape (n, 6) where the second axis is (x1, y1, z1, x2, y2, z2)\"\"\"\n        assert array.shape[1] == 6 and array.ndim == 2, \"Segment array must be of shape (n, 6)\"\n        self._appendData(array, DataType.SEGMENT, key)\n\n    def _appendData(self, data: Union[List, np.ndarray], dataType: DataType, key: InteractionKey = None):\n        if key is None:\n            key = InteractionKey(None, None)\n        self._validateKey(key)\n        previousData = getattr(self._data[key], dataType.value)\n        if previousData is None:\n            previousData = ListArrayContainer()\n            previousData.append(data)\n            setattr(self._data[key], dataType.value, previousData)\n        else:\n            previousData.append(data)\n\n    def _validateKey(self, key: InteractionKey):\n        if key not in self._data:\n            self._data[key] = InteractionData()\n        if key.solidLabel is None:\n            return\n        if key.solidLabel not in self._labels:\n            self._labels[key.solidLabel] = []\n        if key.surfaceLabel is None:\n            return\n        if key.surfaceLabel not in self._labels[key.solidLabel]:\n            self._labels[key.solidLabel].append(key.surfaceLabel)\n\n    def getPoints(self, key: InteractionKey = None) -&gt; np.ndarray:\n        return self._getData(DataType.POINT, key)\n\n    def getRawDataPoints(self, key: InteractionKey = None) -&gt; np.ndarray:\n        \"\"\"All raw 3D data points recorded for this InteractionKey (not binned). Array of shape (n, 4) or (n, 5) where\n        the second axis is (value, x, y, z) or (value, x, y, z, photonID) if photon IDs were logged.\"\"\"\n        return self._getData(DataType.DATA_POINT, key)\n\n    def getSegments(self, key: InteractionKey = None) -&gt; np.ndarray:\n        return self._getData(DataType.SEGMENT, key)\n\n    def _getData(\n        self, dataType: DataType, key: InteractionKey = None, transform: TransformFn = _noTransform\n    ) -&gt; Optional[np.ndarray]:\n        if key and key.solidLabel:\n            if not self._keyExists(key):\n                return None\n            container: ListArrayContainer = getattr(self._data[key], dataType.value)\n            return transform(key, container.getData())\n        else:\n            container = ListArrayContainer()\n            for interactionData in self._data.values():\n                points: Optional[ListArrayContainer] = getattr(interactionData, dataType.value)\n                if points is None:\n                    continue\n                container.extend(points)\n            if len(container) == 0:\n                return None\n            return container.getData()\n\n    def _keyExists(self, key: InteractionKey) -&gt; bool:\n        if key.solidLabel not in self.getStoredSolidLabels():\n            warnings.warn(\n                f\"No data stored for solid labeled '{key.solidLabel}'. Available: {self.getStoredSolidLabels()}. \"\n            )\n        elif key.surfaceLabel and key.surfaceLabel not in self.getStoredSurfaceLabels(key.solidLabel):\n            warnings.warn(\n                f\"No data stored for surface labeled '{key.surfaceLabel}' for solid '{key.solidLabel}'. \"\n                f\"Available: {self.getStoredSurfaceLabels(key.solidLabel)}. \"\n            )\n        if key in self._data:\n            return True\n        return False\n\n    def save(self, filepath: str = None):\n        if filepath is None and self._filepath is None:\n            filepath = self.DEFAULT_LOGGER_PATH\n            warnings.warn(f\"No filepath specified. Saving to {filepath}.\")\n        elif filepath is None:\n            filepath = self._filepath\n\n        with open(filepath, \"wb\") as file:\n            pickle.dump((self._data, self.info, self._labels), file)\n\n    def load(self, filepath: str):\n        self._filepath = filepath\n\n        if not os.path.exists(filepath):\n            warnings.warn(\n                \"No logger file found at '{}'. No data loaded, but it will create a new file \"\n                \"at this location if the logger is saved later on.\".format(filepath)\n            )\n            return\n\n        with open(filepath, \"rb\") as file:\n            self._data, self.info, self._labels = pickle.load(file)\n\n    @property\n    def hasFilePath(self):\n        return self._filepath is not None\n\n    @property\n    def nDataPoints(self) -&gt; int:\n        return sum(len(data.dataPoints) for data in self._data.values())\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Logger.getRawDataPoints","title":"<code>getRawDataPoints(key=None)</code>","text":"<p>All raw 3D data points recorded for this InteractionKey (not binned). Array of shape (n, 4) or (n, 5) where the second axis is (value, x, y, z) or (value, x, y, z, photonID) if photon IDs were logged.</p> Source code in <code>pytissueoptics/scene/logger/logger.py</code> <pre><code>def getRawDataPoints(self, key: InteractionKey = None) -&gt; np.ndarray:\n    \"\"\"All raw 3D data points recorded for this InteractionKey (not binned). Array of shape (n, 4) or (n, 5) where\n    the second axis is (value, x, y, z) or (value, x, y, z, photonID) if photon IDs were logged.\"\"\"\n    return self._getData(DataType.DATA_POINT, key)\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Logger.getSeenSolidLabels","title":"<code>getSeenSolidLabels()</code>","text":"<p>Returns a list of all solid labels that have been logged in the past even if the data was discarded.</p> Source code in <code>pytissueoptics/scene/logger/logger.py</code> <pre><code>def getSeenSolidLabels(self) -&gt; List[str]:\n    \"\"\"Returns a list of all solid labels that have been logged in the past\n    even if the data was discarded.\"\"\"\n    return list(self._labels.keys())\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Logger.getSeenSurfaceLabels","title":"<code>getSeenSurfaceLabels(solidLabel)</code>","text":"<p>Returns a list of all surface labels that have been logged in the past for the given solid even if the data was discarded.</p> Source code in <code>pytissueoptics/scene/logger/logger.py</code> <pre><code>def getSeenSurfaceLabels(self, solidLabel: str) -&gt; List[str]:\n    \"\"\"Returns a list of all surface labels that have been logged in the past\n    for the given solid even if the data was discarded.\"\"\"\n    return self._labels[solidLabel]\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Logger.getStoredSolidLabels","title":"<code>getStoredSolidLabels()</code>","text":"<p>Returns a list of all solid labels that are currently stored in the logger.</p> Source code in <code>pytissueoptics/scene/logger/logger.py</code> <pre><code>def getStoredSolidLabels(self) -&gt; List[str]:\n    \"\"\"Returns a list of all solid labels that are currently stored in the logger.\"\"\"\n    return list(set(key.solidLabel for key in self._data.keys()))\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Logger.getStoredSurfaceLabels","title":"<code>getStoredSurfaceLabels(solidLabel)</code>","text":"<p>Returns a list of all surface labels that are currently stored in the logger.</p> Source code in <code>pytissueoptics/scene/logger/logger.py</code> <pre><code>def getStoredSurfaceLabels(self, solidLabel: str) -&gt; List[str]:\n    \"\"\"Returns a list of all surface labels that are currently stored in the logger.\"\"\"\n    return [\n        key.surfaceLabel\n        for key in self._data.keys()\n        if key.solidLabel == solidLabel and key.surfaceLabel is not None\n    ]\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Logger.logDataPointArray","title":"<code>logDataPointArray(array, key)</code>","text":"<p>'array' must be of shape (n, 4) or (n, 5) where the second axis is (value, x, y, z) or (value, x, y, z, photonID). The photonID column is optional.</p> Source code in <code>pytissueoptics/scene/logger/logger.py</code> <pre><code>def logDataPointArray(self, array: np.ndarray, key: InteractionKey):\n    \"\"\"'array' must be of shape (n, 4) or (n, 5) where the second axis is (value, x, y, z)\n    or (value, x, y, z, photonID). The photonID column is optional.\"\"\"\n    assert array.shape[1] in [4, 5] and array.ndim == 2, \"Data point array must be of shape (n, 4) or (n, 5)\"\n    self._appendData(array, DataType.DATA_POINT, key)\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Logger.logPointArray","title":"<code>logPointArray(array, key=None)</code>","text":"<p>'array' must be of shape (n, 3) where the second axis is (x, y, z)</p> Source code in <code>pytissueoptics/scene/logger/logger.py</code> <pre><code>def logPointArray(self, array: np.ndarray, key: InteractionKey = None):\n    \"\"\"'array' must be of shape (n, 3) where the second axis is (x, y, z)\"\"\"\n    assert array.shape[1] == 3 and array.ndim == 2, \"Point array must be of shape (n, 3)\"\n    self._appendData(array, DataType.POINT, key)\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Logger.logSegmentArray","title":"<code>logSegmentArray(array, key=None)</code>","text":"<p>'array' must be of shape (n, 6) where the second axis is (x1, y1, z1, x2, y2, z2)</p> Source code in <code>pytissueoptics/scene/logger/logger.py</code> <pre><code>def logSegmentArray(self, array: np.ndarray, key: InteractionKey = None):\n    \"\"\"'array' must be of shape (n, 6) where the second axis is (x1, y1, z1, x2, y2, z2)\"\"\"\n    assert array.shape[1] == 6 and array.ndim == 2, \"Segment array must be of shape (n, 6)\"\n    self._appendData(array, DataType.SEGMENT, key)\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Scene","title":"<code>Scene</code>","text":"<p>               Bases: <code>Displayable</code></p> Source code in <code>pytissueoptics/scene/scene/scene.py</code> <pre><code>class Scene(Displayable):\n    def __init__(self, solids: List[Solid] = None, ignoreIntersections=False, worldMaterial=None):\n        self._solids: List[Solid] = []\n        self._ignoreIntersections = ignoreIntersections\n        self._solidsContainedIn: Dict[str, List[str]] = {}\n        self._worldMaterial = worldMaterial\n\n        if solids:\n            for solid in solids:\n                self.add(solid)\n\n        self.resetOutsideMaterial()\n\n    def add(self, solid: Solid, position: Vector = None):\n        if position:\n            solid.translateTo(position)\n        self._validateLabel(solid)\n        if not self._ignoreIntersections:\n            self._validatePosition(solid)\n        self._solids.append(solid)\n\n    @property\n    def solids(self):\n        return self._solids\n\n    def addToViewer(self, viewer: Abstract3DViewer, representation=\"surface\", colormap=\"bone\", opacity=0.1, **kwargs):\n        viewer.add(*self.solids, representation=representation, colormap=colormap, opacity=opacity, **kwargs)\n\n    def getWorldEnvironment(self) -&gt; Environment:\n        return Environment(self._worldMaterial)\n\n    def _validatePosition(self, newSolid: Solid):\n        \"\"\"Assert newSolid position is valid and make proper adjustments so that the\n        material at each solid interface is well-defined.\"\"\"\n        if len(self._solids) == 0:\n            return\n\n        intersectingSuspects = self._findIntersectingSuspectsFor(newSolid)\n        if len(intersectingSuspects) == 0:\n            return\n\n        intersectingSuspects.sort(key=lambda s: s.getBoundingBox().xMax - s.getBoundingBox().xMin, reverse=True)\n\n        for otherSolid in intersectingSuspects:\n            if newSolid.contains(*otherSolid.getVertices()):\n                self._processContainedSolid(otherSolid, container=newSolid)\n                break\n            elif otherSolid.contains(*newSolid.getVertices()):\n                self._processContainedSolid(newSolid, container=otherSolid)\n            else:\n                raise NotImplementedError(\n                    \"Cannot place a solid that partially intersects with an existing solid. \"\n                    \"Since this might be underestimating containment, you can also create a \"\n                    \"scene with 'ignoreIntersections=True' to ignore this error and manually \"\n                    \"handle environments of contained solids with \"\n                    \"containedSolid.setOutsideEnvironment(containerSolid.getEnvironment()).\"\n                )\n\n    def _processContainedSolid(self, solid: Solid, container: Solid):\n        if container.isStack():\n            containerEnv = self._getEnvironmentOfStackAt(solid.position, container)\n        else:\n            containerEnv = container.getEnvironment()\n        solid.setOutsideEnvironment(containerEnv)\n\n        containerLabel = containerEnv.solid.getLabel()\n        if containerLabel not in self._solidsContainedIn:\n            self._solidsContainedIn[containerLabel] = [solid.getLabel()]\n        else:\n            self._solidsContainedIn[containerLabel].append(solid.getLabel())\n\n    def _validateLabel(self, solid):\n        labelSet = set(s.getLabel() for s in self.solids)\n        if solid.getLabel() not in labelSet:\n            return\n        idx = 2\n        while f\"{solid.getLabel()}_{idx}\" in labelSet:\n            idx += 1\n        warnings.warn(\n            f\"A solid with label '{solid.getLabel()}' already exists in the scene. \"\n            f\"Renaming to '{solid.getLabel()}_{idx}'.\"\n        )\n        solid.setLabel(f\"{solid.getLabel()}_{idx}\")\n\n    def _findIntersectingSuspectsFor(self, solid) -&gt; List[Solid]:\n        solidBBox = solid.getBoundingBox()\n        intersectingSuspects = []\n        for otherSolid in self._solids:\n            if solidBBox.intersects(otherSolid.getBoundingBox()):\n                intersectingSuspects.append(otherSolid)\n        return intersectingSuspects\n\n    def getSolids(self) -&gt; List[Solid]:\n        return self._solids\n\n    def getSolid(self, solidLabel: str) -&gt; Solid:\n        for solid in self._solids:\n            if solid.getLabel().lower() == solidLabel.lower():\n                return solid\n            if not solid.isStack():\n                continue\n            for layerLabel in solid.getLayerLabels():\n                if layerLabel.lower() == solidLabel.lower():\n                    return solid\n        raise ValueError(f\"Solid '{solidLabel}' not found in scene. Available solids: {self.getSolidLabels()}\")\n\n    def getSolidLabels(self) -&gt; List[str]:\n        labels = []\n        for solid in self._solids:\n            if solid.isStack():\n                labels.extend(solid.getLayerLabels())\n            else:\n                labels.append(solid.getLabel())\n        return labels\n\n    def getSurfaceLabels(self, solidLabel) -&gt; List[str]:\n        solid = self.getSolid(solidLabel)\n        if solid is None:\n            return []\n        if solid.isStack() and solid.getLabel() != solidLabel:\n            return solid.getLayerSurfaceLabels(solidLabel)\n        return solid.surfaceLabels\n\n    def getContainedSolidLabels(self, solidLabel: str) -&gt; List[str]:\n        return self._solidsContainedIn.get(solidLabel, [])\n\n    def getPolygons(self) -&gt; List[Polygon]:\n        polygons = []\n        for solid in self._solids:\n            polygons.extend(solid.getPolygons())\n        return polygons\n\n    def getMaterials(self) -&gt; list:\n        materials = [self._worldMaterial]\n        for solid in self._solids:\n            if solid.isDetector:\n                continue\n            surfaceLabels = solid.surfaceLabels\n            for surfaceLabel in surfaceLabels:\n                material = solid.getPolygons(surfaceLabel)[0].insideEnvironment.material\n                if material not in materials:\n                    materials.append(material)\n        return list(materials)\n\n    def getMaterial(self, solidLabel: str):\n        solid = self.getSolid(solidLabel)\n        if solid.isStack():\n            layerSurfaceLabel = [s for s in solid.getLayerSurfaceLabels(solidLabel) if INTERFACE_KEY not in s][0]\n            return solid.getEnvironment(layerSurfaceLabel).material\n        else:\n            return solid.getEnvironment().material\n\n    def getBoundingBox(self) -&gt; Optional[BoundingBox]:\n        if len(self._solids) == 0:\n            return None\n\n        bbox = self._solids[0].getBoundingBox().copy()\n        for solid in self._solids[1:]:\n            bbox.extendTo(solid.getBoundingBox())\n        return bbox\n\n    def resetOutsideMaterial(self):\n        outsideEnvironment = self.getWorldEnvironment()\n        for solid in self._solids:\n            if self._isHidden(solid.getLabel()):\n                continue\n            solid.setOutsideEnvironment(outsideEnvironment)\n\n    def _isHidden(self, solidLabel: str) -&gt; bool:\n        for hiddenLabels in self._solidsContainedIn.values():\n            if solidLabel in hiddenLabels:\n                return True\n        return False\n\n    def getEnvironmentAt(self, position: Vector) -&gt; Environment:\n        # First, recursively look if position is in a contained solid.\n        for containerLabel in self._solidsContainedIn.keys():\n            env = self._getEnvironmentOfContainerAt(position, containerLabel)\n            if env is not None:\n                return env\n\n        for solid in self._solids:\n            if solid.contains(position):\n                if solid.isStack():\n                    return self._getEnvironmentOfStackAt(position, solid)\n                return solid.getEnvironment()\n        return self.getWorldEnvironment()\n\n    def _getEnvironmentOfContainerAt(self, position: Vector, containerLabel: str) -&gt; Optional[Environment]:\n        containerSolid = self.getSolid(containerLabel)\n        if not containerSolid.contains(position):\n            return None\n        for containedLabel in self.getContainedSolidLabels(containerLabel):\n            containedEnv = self._getEnvironmentOfContainerAt(position, containedLabel)\n            if containedEnv:\n                return containedEnv\n        if containerSolid.isStack():\n            return self._getEnvironmentOfStackAt(position, containerSolid)\n        return containerSolid.getEnvironment()\n\n    @staticmethod\n    def _getEnvironmentOfStackAt(position: Vector, stack: Solid) -&gt; Environment:\n        \"\"\"Returns the environment of the stack at the given position.\n\n        To do that we first find the interface in the stack that is closest to the given position.\n        At the same time we find on which side of the interface we are and return the environment\n        of this side from any surface polygon.\n        \"\"\"\n        environment = None\n        closestDistance = sys.maxsize\n        for surfaceLabel in stack.surfaceLabels:\n            if INTERFACE_KEY not in surfaceLabel:\n                continue\n            planePolygon = stack.surfaces.getPolygons(surfaceLabel)[0]\n            planeNormal = planePolygon.normal\n            planePoint = planePolygon.vertices[0]\n            v = position - planePoint\n            distanceFromPlane = v.dot(planeNormal)\n            if abs(distanceFromPlane) &lt; closestDistance:\n                closestDistance = abs(distanceFromPlane)\n                isInside = distanceFromPlane &lt; 0\n                environment = planePolygon.insideEnvironment if isInside else planePolygon.outsideEnvironment\n        return environment\n\n    def __hash__(self):\n        solidHash = hash(tuple(sorted([hash(s) for s in self._solids])))\n        worldMaterialHash = hash(self._worldMaterial) if self._worldMaterial else 0\n        return hash((solidHash, worldMaterialHash))\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Sphere","title":"<code>Sphere</code>","text":"<p>               Bases: <code>Ellipsoid</code></p> <p>The Sphere is the 3D analog to the circle. Meshing a sphere requires an infinite number of vertices. The position refers to the vector from global origin to its centroid. The radius of the sphere will determine the outermost distance from its centroid.</p> <p>This class offers two possible methods to generate the sphere mesh. - With Quads: Specify the number of separation lines on the vertical axis and the horizontal axis of the sphere. - With Triangle: Specify the order of splitting. This will generate what is known as an IcoSphere.</p> Source code in <code>pytissueoptics/scene/solids/sphere.py</code> <pre><code>class Sphere(Ellipsoid):\n    \"\"\"\n    The Sphere is the 3D analog to the circle. Meshing a sphere requires an infinite number of vertices.\n    The position refers to the vector from global origin to its centroid.\n    The radius of the sphere will determine the outermost distance from its centroid.\n\n    This class offers two possible methods to generate the sphere mesh.\n    - With Quads: Specify the number of separation lines on the vertical axis and the horizontal axis of the sphere.\n    - With Triangle: Specify the order of splitting. This will generate what is known as an IcoSphere.\n    \"\"\"\n\n    def __init__(\n        self,\n        radius: float = 1.0,\n        order: int = 3,\n        position: Vector = Vector(0, 0, 0),\n        material=None,\n        label: str = \"sphere\",\n        primitive: str = primitives.DEFAULT,\n        smooth: bool = True,\n    ):\n        self._radius = radius\n\n        super().__init__(\n            a=radius,\n            b=radius,\n            c=radius,\n            order=order,\n            position=position,\n            material=material,\n            label=label,\n            primitive=primitive,\n            smooth=smooth,\n        )\n\n    @property\n    def radius(self):\n        return self._radius\n\n    def _computeQuadMesh(self):\n        raise NotImplementedError\n\n    def contains(self, *vertices: Vector) -&gt; bool:\n        \"\"\"Only returns true if all vertices are inside the minimum radius of the sphere\n        (more restrictive with low order spheres).\"\"\"\n        minRadius = self._getMinimumRadius()\n        for vertex in vertices:\n            relativeVertex = vertex - self.position\n            if relativeVertex.getNorm() &gt;= minRadius:\n                return False\n        return True\n\n    def _getMinimumRadius(self) -&gt; float:\n        return (1 - self._getRadiusError()) * self._radius\n\n    def _radiusTowards(self, vertex) -&gt; float:\n        return self.radius\n\n    def _geometryParams(self) -&gt; dict:\n        return {\n            \"radius\": self._radius,\n            \"order\": self._order,\n        }\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Sphere.contains","title":"<code>contains(*vertices)</code>","text":"<p>Only returns true if all vertices are inside the minimum radius of the sphere (more restrictive with low order spheres).</p> Source code in <code>pytissueoptics/scene/solids/sphere.py</code> <pre><code>def contains(self, *vertices: Vector) -&gt; bool:\n    \"\"\"Only returns true if all vertices are inside the minimum radius of the sphere\n    (more restrictive with low order spheres).\"\"\"\n    minRadius = self._getMinimumRadius()\n    for vertex in vertices:\n        relativeVertex = vertex - self.position\n        if relativeVertex.getNorm() &gt;= minRadius:\n            return False\n    return True\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.SymmetricLens","title":"<code>SymmetricLens</code>","text":"<p>               Bases: <code>ThickLens</code></p> <p>A symmetrical thick lens of focal length <code>f</code> in air.</p> Source code in <code>pytissueoptics/scene/solids/lens.py</code> <pre><code>class SymmetricLens(ThickLens):\n    \"\"\"A symmetrical thick lens of focal length `f` in air.\"\"\"\n\n    def __init__(\n        self,\n        f: float,\n        diameter: float,\n        thickness: float,\n        material: RefractiveMaterial,\n        position: Vector = Vector(0, 0, 0),\n        label: str = \"lens\",\n        primitive: str = primitives.DEFAULT,\n        smooth: bool = True,\n        u: int = 24,\n        v: int = 2,\n        s: int = 24,\n    ):\n        # For thick lenses, the focal length is given by the lensmaker's equation:\n        # 1/f = (n - 1) * (1/R1 - 1/R2 + (n - 1) * d / (n * R1 * R2))\n        # with R2 = -R1, we get the following quadratic equation to solve:\n        # 1/f = (n - 1) * (2/R - (n - 1) * d / (n * R^2))\n        n = material.n\n        p = math.sqrt(f * n * (f * n - thickness)) * (n - 1) / n\n        R = f * (n - 1) + p * np.sign(f)\n        super().__init__(R, -R, diameter, thickness, position, material, label, primitive, smooth, u, v, s)\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.ThickLens","title":"<code>ThickLens</code>","text":"<p>               Bases: <code>Cylinder</code></p> <p>The Lens is defined by a front radius, a back radius, a diameter and a thickness (along its center). A positive frontRadius means that the front surface is convex. This is reversed for the back surface. A flat surface is obtained by setting the corresponding radius to 0 or math.inf. The position refers to the vector from global origin to its centroid. The generated mesh will be divided into the following subgroups: Front, Side and Back. By default, front will point towards the negative z-axis.</p> Source code in <code>pytissueoptics/scene/solids/lens.py</code> <pre><code>class ThickLens(Cylinder):\n    \"\"\"\n    The Lens is defined by a front radius, a back radius, a diameter and a thickness (along its center).\n    A positive frontRadius means that the front surface is convex. This is reversed for the back surface.\n    A flat surface is obtained by setting the corresponding radius to 0 or math.inf.\n    The position refers to the vector from global origin to its centroid.\n    The generated mesh will be divided into the following subgroups: Front, Side and Back.\n    By default, front will point towards the negative z-axis.\n    \"\"\"\n\n    def __init__(\n        self,\n        frontRadius: float,\n        backRadius: float,\n        diameter: float,\n        thickness: float,\n        position: Vector = Vector(0, 0, 0),\n        material=None,\n        label: str = \"thick lens\",\n        primitive: str = primitives.DEFAULT,\n        smooth: bool = True,\n        u: int = 24,\n        v: int = 2,\n        s: int = 24,\n    ):\n        frontRadius = frontRadius if frontRadius != 0 else math.inf\n        backRadius = backRadius if backRadius != 0 else math.inf\n        if abs(frontRadius) &lt;= diameter / 2:\n            raise ValueError(\n                f\"Front radius must be greater than the lens radius. Front radius: {frontRadius}, \"\n                f\"lens radius: {diameter / 2}\"\n            )\n        if abs(backRadius) &lt;= diameter / 2:\n            raise ValueError(\n                f\"Back radius must be greater than the lens radius. Back radius: {backRadius}, \"\n                f\"lens radius: {diameter / 2}\"\n            )\n\n        self._diameter = diameter\n        self._frontRadius = frontRadius\n        self._backRadius = backRadius\n        self._thickness = thickness\n\n        length = self._computeEdgeThickness(thickness)\n        super().__init__(\n            radius=diameter / 2,\n            length=length,\n            u=u,\n            v=v,\n            s=s,\n            position=position,\n            material=material,\n            label=label,\n            primitive=primitive,\n            smooth=smooth,\n        )\n\n    @property\n    def _hasFrontCurvature(self) -&gt; bool:\n        return self._frontRadius != 0 and self._frontRadius != math.inf\n\n    @property\n    def _hasBackCurvature(self) -&gt; bool:\n        return self._backRadius != 0 and self._backRadius != math.inf\n\n    def _computeEdgeThickness(self, centerThickness) -&gt; float:\n        \"\"\"Returns the thickness of the lens on its side. This is the length required to build the base cylinder\n        before applying surface curvature.\"\"\"\n        dt1, dt2 = 0, 0\n        if self._hasFrontCurvature:\n            dt1 = abs(self._frontRadius) - math.sqrt(self._frontRadius**2 - self._diameter**2 / 4)\n            dt1 *= np.sign(self._frontRadius)\n        if self._hasBackCurvature:\n            dt2 = abs(self._backRadius) - math.sqrt(self._backRadius**2 - self._diameter**2 / 4)\n            dt2 *= -np.sign(self._backRadius)\n        edgeThickness = centerThickness - dt1 - dt2\n        if edgeThickness &lt; 0:\n            raise ValueError(\"Desired center thickness is too small for the given radii and diameter.\")\n        return edgeThickness\n\n    @property\n    def centerThickness(self) -&gt; float:\n        return (self._frontCenter - self._backCenter).getNorm()\n\n    @property\n    def edgeThickness(self) -&gt; float:\n        return self._length\n\n    @property\n    def frontRadius(self) -&gt; float:\n        return self._frontRadius\n\n    @property\n    def backRadius(self) -&gt; float:\n        return self._backRadius\n\n    @property\n    def focalLength(self) -&gt; float:\n        \"\"\"Returns the focal length of the lens in air. Requires a refractive material to be defined.\"\"\"\n        if self._material is None or not issubclass(type(self._material), RefractiveMaterial):\n            raise ValueError(\"Cannot compute focal length without refractive material defined.\")\n        # For thick lenses, the focal length is given by the lensmaker's equation:\n        # 1/f = (n - 1) * (1/R1 - 1/R2 + (n - 1) * d / (n * R1 * R2))\n        n = self._material.n\n        R1 = self._frontRadius\n        R2 = self._backRadius\n        d = self.centerThickness\n        if n == 1:\n            return math.inf\n        if self._hasFrontCurvature and self._hasBackCurvature:\n            return 1 / ((n - 1) * (1 / R1 - 1 / R2 + (n - 1) * d / (n * R1 * R2)))\n        if self._hasFrontCurvature:\n            return R1 / (n - 1)\n        if self._hasBackCurvature:\n            return R2 / (n - 1)\n        return math.inf\n\n    def _computeVerticesOfLayers(self) -&gt; tuple:\n        frontLayers, lateralLayers, backLayers = super()._computeVerticesOfLayers()\n\n        if self._hasFrontCurvature:\n            frontVertices = list(itertools.chain.from_iterable(frontLayers)) + [self._frontCenter]\n            self._applyCurvature(self._frontRadius, frontVertices)\n        if self._hasBackCurvature:\n            backVertices = list(itertools.chain.from_iterable(backLayers)) + [self._backCenter]\n            self._applyCurvature(self._backRadius, backVertices)\n\n        if self._frontCenter.z &gt; self._backCenter.z:\n            raise ValueError(\"Not a valid lens: curved surfaces intersect.\")\n        return frontLayers, lateralLayers, backLayers\n\n    def _applyCurvature(self, radius: float, vertices: List[Vertex]):\n        # At this point, all vertices are on the same z plane.\n        surfaceZ = vertices[0].z\n        # The sphere origin is simply found by setting the z coordinate so that the distance to\n        # the surface perimeter equals the desired radius.\n        sphereOrigin = Vector(0, 0, surfaceZ + math.sqrt(radius**2 - self._radius**2) * np.sign(radius))\n        for vertex in vertices:\n            direction = vertex - sphereOrigin\n            direction.normalize()\n            vertex.update(*(sphereOrigin + direction * abs(radius)).array)\n\n    def smooth(self, surfaceLabel: str = None, reset: bool = True):\n        if surfaceLabel:\n            return super(Cylinder, self).smooth(surfaceLabel, reset)\n        for surfaceLabel in [\"front\", \"back\"]:\n            self.smooth(surfaceLabel, reset=False)\n\n    def _geometryParams(self) -&gt; dict:\n        return {\n            \"diameter\": self._diameter,\n            \"frontRadius\": self._frontRadius,\n            \"backRadius\": self._backRadius,\n            \"thickness\": self._thickness,\n            \"length\": self._length,\n            \"u\": self._u,\n            \"v\": self._v,\n            \"s\": self._s,\n        }\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.ThickLens.focalLength","title":"<code>focalLength</code>  <code>property</code>","text":"<p>Returns the focal length of the lens in air. Requires a refractive material to be defined.</p>"},{"location":"api/scene/#pytissueoptics.scene.Vector","title":"<code>Vector</code>","text":"<p>Basic implementation of a mutable 3D Vector. It implements most of the basic vector operation. Mutability is necessary when working with shared object references for expected behavior.</p> Source code in <code>pytissueoptics/scene/geometry/vector.py</code> <pre><code>class Vector:\n    \"\"\"\n    Basic implementation of a mutable 3D Vector. It implements most of the basic vector operation.\n    Mutability is necessary when working with shared object references for expected behavior.\n    \"\"\"\n\n    def __init__(self, x: float = 0, y: float = 0, z: float = 0):\n        self._x = x\n        self._y = y\n        self._z = z\n\n    @property\n    def x(self):\n        return self._x\n\n    @property\n    def y(self):\n        return self._y\n\n    @property\n    def z(self):\n        return self._z\n\n    def __repr__(self):\n        return f\"&lt;Vector&gt;:({self._x}, {self._y}, {self._z})\"\n\n    def __iter__(self):\n        return iter((self._x, self._y, self._z))\n\n    def __eq__(self, other: \"Vector\"):\n        tol = 1e-5\n        if (\n            math.isclose(other._x, self._x, abs_tol=tol)\n            and math.isclose(other._y, self._y, abs_tol=tol)\n            and math.isclose(other._z, self._z, abs_tol=tol)\n        ):\n            return True\n        else:\n            return False\n\n    def __sub__(self, other: \"Vector\") -&gt; \"Vector\":\n        return Vector(self._x - other._x, self._y - other._y, self._z - other._z)\n\n    def __add__(self, other: \"Vector\") -&gt; \"Vector\":\n        return Vector(self._x + other._x, self._y + other._y, self._z + other._z)\n\n    def __mul__(self, scalar: float) -&gt; \"Vector\":\n        return Vector(self._x * scalar, self._y * scalar, self._z * scalar)\n\n    def __truediv__(self, scalar: float) -&gt; \"Vector\":\n        return Vector(self._x / scalar, self._y / scalar, self._z / scalar)\n\n    def add(self, other: \"Vector\"):\n        self._x += other._x\n        self._y += other._y\n        self._z += other._z\n\n    def subtract(self, other: \"Vector\"):\n        self._x -= other._x\n        self._y -= other._y\n        self._z -= other._z\n\n    def multiply(self, scalar: float):\n        self._x *= scalar\n        self._y *= scalar\n        self._z *= scalar\n\n    def divide(self, scalar: float):\n        self._x /= scalar\n        self._y /= scalar\n        self._z /= scalar\n\n    def getNorm(self) -&gt; float:\n        return (self._x**2 + self._y**2 + self._z**2) ** (1 / 2)\n\n    def normalize(self):\n        norm = self.getNorm()\n        if norm != 0:\n            self._x = self._x / norm\n            self._y = self._y / norm\n            self._z = self._z / norm\n\n    def cross(self, other: \"Vector\") -&gt; \"Vector\":\n        ux, uy, uz = self._x, self._y, self._z\n        vx, vy, vz = other._x, other._y, other._z\n        return Vector(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx)\n\n    def dot(self, other: \"Vector\") -&gt; float:\n        return self._x * other._x + self._y * other._y + self._z * other._z\n\n    @property\n    def array(self) -&gt; list:\n        return [self._x, self._y, self._z]\n\n    def update(self, x: float, y: float, z: float):\n        self._x = x\n        self._y = y\n        self._z = z\n\n    def copy(self) -&gt; \"Vector\":\n        return Vector(self._x, self._y, self._z)\n\n    def rotateAround(self, unitAxis: \"Vector\", theta: float):\n        \"\"\"\n        Rotate the vector around `unitAxis` by `theta` radians. Assumes the axis to be a unit vector.\n        Uses Rodrigues' rotation formula.\n        \"\"\"\n        # This is the most expensive (and most common)\n        # operation when performing Monte Carlo in tissue\n        # (15% of time spent here). It is difficult to optimize without\n        # making it even less readable than it currently is\n        # http://en.wikipedia.org/wiki/Rotation_matrix\n        #\n        # Several options were tried in the past such as\n        # external not-so-portable C library, unreadable\n        # shortcuts, sine and cosine lookup tables, etc...\n        # and the performance gain was minimal (&lt;20%).\n        # For now, this is the best, most readable solution.\n\n        cost = math.cos(theta)\n        sint = math.sin(theta)\n        one_cost = 1 - cost\n\n        ux = unitAxis.x\n        uy = unitAxis.y\n        uz = unitAxis.z\n\n        X = self._x\n        Y = self._y\n        Z = self._z\n\n        x = (\n            (cost + ux * ux * one_cost) * X\n            + (ux * uy * one_cost - uz * sint) * Y\n            + (ux * uz * one_cost + uy * sint) * Z\n        )\n        y = (\n            (uy * ux * one_cost + uz * sint) * X\n            + (cost + uy * uy * one_cost) * Y\n            + (uy * uz * one_cost - ux * sint) * Z\n        )\n        z = (\n            (uz * ux * one_cost - uy * sint) * X\n            + (uz * uy * one_cost + ux * sint) * Y\n            + (cost + uz * uz * one_cost) * Z\n        )\n\n        self.update(x, y, z)\n\n    def getAnyOrthogonal(self) -&gt; \"Vector\":\n        if abs(self._z) &lt; abs(self._x):\n            return Vector(self._y, -self._x, 0)\n\n        return Vector(0, -self._z, self._y)\n\n    def __hash__(self):\n        return hash((self._x, self._y, self._z))\n</code></pre>"},{"location":"api/scene/#pytissueoptics.scene.Vector.rotateAround","title":"<code>rotateAround(unitAxis, theta)</code>","text":"<p>Rotate the vector around <code>unitAxis</code> by <code>theta</code> radians. Assumes the axis to be a unit vector. Uses Rodrigues' rotation formula.</p> Source code in <code>pytissueoptics/scene/geometry/vector.py</code> <pre><code>def rotateAround(self, unitAxis: \"Vector\", theta: float):\n    \"\"\"\n    Rotate the vector around `unitAxis` by `theta` radians. Assumes the axis to be a unit vector.\n    Uses Rodrigues' rotation formula.\n    \"\"\"\n    # This is the most expensive (and most common)\n    # operation when performing Monte Carlo in tissue\n    # (15% of time spent here). It is difficult to optimize without\n    # making it even less readable than it currently is\n    # http://en.wikipedia.org/wiki/Rotation_matrix\n    #\n    # Several options were tried in the past such as\n    # external not-so-portable C library, unreadable\n    # shortcuts, sine and cosine lookup tables, etc...\n    # and the performance gain was minimal (&lt;20%).\n    # For now, this is the best, most readable solution.\n\n    cost = math.cos(theta)\n    sint = math.sin(theta)\n    one_cost = 1 - cost\n\n    ux = unitAxis.x\n    uy = unitAxis.y\n    uz = unitAxis.z\n\n    X = self._x\n    Y = self._y\n    Z = self._z\n\n    x = (\n        (cost + ux * ux * one_cost) * X\n        + (ux * uy * one_cost - uz * sint) * Y\n        + (ux * uz * one_cost + uy * sint) * Z\n    )\n    y = (\n        (uy * ux * one_cost + uz * sint) * X\n        + (cost + uy * uy * one_cost) * Y\n        + (uy * uz * one_cost - ux * sint) * Z\n    )\n    z = (\n        (uz * ux * one_cost - uy * sint) * X\n        + (uz * uy * one_cost + ux * sint) * Y\n        + (cost + uz * uz * one_cost) * Z\n    )\n\n    self.update(x, y, z)\n</code></pre>"}]}